name: Deploy to Staging

on:
  push:
    branches: [develop]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v4
        with:
          go-version: '1.25.1'
      
      - name: Build
        run: go build -o app ./cmd/api
      
      - name: Build Docker image
        run: docker build -t monogo:staging .
      
      - name: Deploy to staging
        run: echo "Deploy to staging environment"
        env:
          POSTGRES_PASSWORD: testpassword
          POSTGRES_USER: testuser
          POSTGRES_DB: testdb
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
      
      redis:
        image: redis:7-alpine
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379

    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ¹ Setup Go
        uses: actions/setup-go@v4
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: ğŸ“¦ Download dependencies
        run: go mod download

      - name: ğŸ§ª Run unit tests
        env:
          DATABASE_URL: postgres://testuser:testpassword@localhost:5432/testdb?sslmode=disable
          REDIS_URL: redis://localhost:6379
        run: |
          go test -v -race -coverprofile=coverage.out -covermode=atomic ./...

      - name: ğŸ”§ Run integration tests
        env:
          DATABASE_URL: postgres://testuser:testpassword@localhost:5432/testdb?sslmode=disable
          REDIS_URL: redis://localhost:6379
        run: |
          # Se existirem testes de integraÃ§Ã£o
          if [ -d "tests/integration" ]; then
            go test -v -tags=integration ./tests/integration/...
          fi

      - name: ğŸš€ Run end-to-end tests
        env:
          DATABASE_URL: postgres://testuser:testpassword@localhost:5432/testdb?sslmode=disable
          REDIS_URL: redis://localhost:6379
        run: |
          # Build application for e2e tests
          go build -o ./bin/monogo ./cmd/api
          
          # Start application in background
          ./bin/monogo auth --port=8080 &
          APP_PID=$!
          
          # Wait for application to start
          sleep 5
          
          # Basic health check
          curl -f http://localhost:8080/health || exit 1
          
          # Stop application
          kill $APP_PID

      - name: ğŸ“Š Upload test results
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: test-results
          path: |
            coverage.out
            test-results.xml

  # ğŸ—ï¸ Build and Push Container
  build-and-push:
    name: ğŸ—ï¸ Build & Push Container
    runs-on: ubuntu-latest
    needs: extended-tests
    outputs:
      image: ${{ steps.image.outputs.image }}
      digest: ${{ steps.build.outputs.digest }}
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ³ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: ğŸ” Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: ğŸ·ï¸ Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=sha,prefix={{branch}}-
            type=raw,value=staging

      - name: ğŸ—ï¸ Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64,linux/arm64

      - name: ğŸ“ Generate image output
        id: image
        run: echo "image=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:staging" >> $GITHUB_OUTPUT

  # ğŸ”’ Security Scanning
  security-scan:
    name: ğŸ”’ Security Scan
    runs-on: ubuntu-latest
    needs: build-and-push
    steps:
      - name: ğŸ” Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ needs.build-and-push.outputs.image }}
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: ğŸ“¤ Upload Trivy scan results
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: 'trivy-results.sarif'

  # ğŸš€ Deploy to Staging
  deploy-staging:
    name: ğŸš€ Deploy to Staging
    runs-on: ubuntu-latest
    needs: [build-and-push, security-scan]
    environment:
      name: staging
      url: https://staging.monogo.app
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: âš™ï¸ Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: ğŸ” Configure AWS credentials (if using EKS)
        if: false  # Ativar se usando AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: ğŸ¯ Deploy to Kubernetes
        run: |
          # Substituir placeholders no deployment
          sed -i "s|IMAGE_TAG|${{ needs.build-and-push.outputs.image }}|g" k8s/staging/deployment.yaml
          
          # Aplicar configuraÃ§Ãµes do Kubernetes
          kubectl apply -f k8s/staging/ --validate=false
          
          # Aguardar deployment
          kubectl rollout status deployment/monogo-staging -n staging --timeout=300s

      - name: ğŸ¥ Health check
        run: |
          # Aguardar que o serviÃ§o esteja disponÃ­vel
          sleep 30
          
          # Verificar health endpoint
          max_attempts=10
          attempt=1
          
          while [ $attempt -le $max_attempts ]; do
            if curl -f https://staging.monogo.app/health; then
              echo "âœ… Health check passed!"
              break
            else
              echo "â³ Health check failed, attempt $attempt/$max_attempts"
              sleep 10
              attempt=$((attempt + 1))
            fi
          done
          
          if [ $attempt -gt $max_attempts ]; then
            echo "âŒ Health check failed after $max_attempts attempts"
            exit 1
          fi

      - name: ğŸ§ª Smoke tests
        run: |
          echo "ğŸ§ª Running smoke tests against staging..."
          
          # Testes bÃ¡sicos de API
          curl -f https://staging.monogo.app/health
          curl -f https://staging.monogo.app/api/v1/health
          
          # Se tiver endpoints especÃ­ficos para testar
          # curl -f https://staging.monogo.app/api/v1/auth/healthcheck

  # ğŸ“Š Performance Testing
  performance-test:
    name: ğŸ“Š Performance Testing
    runs-on: ubuntu-latest
    needs: deploy-staging
    if: github.event_name == 'push'  # SÃ³ roda em push, nÃ£o em workflow_dispatch
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: âš¡ Install k6
        run: |
          sudo gpg -k
          sudo gpg --no-default-keyring --keyring /usr/share/keyrings/k6-archive-keyring.gpg --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys C5AD17C747E3415A3642D57D77C6C491D6AC1D69
          echo "deb [signed-by=/usr/share/keyrings/k6-archive-keyring.gpg] https://dl.k6.io/deb stable main" | sudo tee /etc/apt/sources.list.d/k6.list
          sudo apt-get update
          sudo apt-get install k6

      - name: ğŸƒ Run load tests
        run: |
          # Criar script bÃ¡sico de load test se nÃ£o existir
          if [ ! -f "tests/load/basic.js" ]; then
            mkdir -p tests/load
            cat > tests/load/basic.js << 'EOF'
          import http from 'k6/http';
          import { check, sleep } from 'k6';

          export let options = {
            stages: [
              { duration: '30s', target: 20 },
              { duration: '1m', target: 20 },
              { duration: '30s', target: 0 },
            ],
          };

          export default function () {
            let response = http.get('https://staging.monogo.app/health');
            check(response, { 'status was 200': (r) => r.status == 200 });
            sleep(1);
          }
          EOF
          fi
          
          # Executar testes de carga
          k6 run tests/load/basic.js

  # ğŸ“¢ Notification
  notify:
    name: ğŸ“¢ Deployment Notification
    runs-on: ubuntu-latest
    needs: [deploy-staging, performance-test]
    if: always()
    steps:
      - name: ğŸ’¬ Notify deployment status
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const deploymentStatus = '${{ needs.deploy-staging.result }}';
            const performanceStatus = '${{ needs.performance-test.result }}';
            
            let status = 'âœ… Success';
            let color = '28a745';
            
            if (deploymentStatus !== 'success' || performanceStatus !== 'success') {
              status = 'âŒ Failed';
              color = 'd73a49';
            }
            
            const message = `## ğŸš€ Staging Deployment ${status}
            
            **Branch:** \`develop\`
            **Commit:** \`${{ github.sha }}\`
            **Environment:** Staging
            
            **Results:**
            - Deployment: ${deploymentStatus === 'success' ? 'âœ…' : 'âŒ'} ${deploymentStatus}
            - Performance Tests: ${performanceStatus === 'success' ? 'âœ…' : 'âŒ'} ${performanceStatus}
            
            **Environment URL:** https://staging.monogo.app
            
            ---
            *Automated deployment by GitHub Actions ğŸ¤–*`;
            
            // Se tiver Slack webhook configurado
            if ('${{ secrets.SLACK_WEBHOOK }}') {
              // Enviar para Slack
              console.log('Would send to Slack:', message);
            }