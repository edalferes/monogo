name: ü§ñ PR Validation with AI

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]
    branches:
      - develop
      - main

permissions:
  contents: read
  pull-requests: write
  checks: write
  issues: write

env:
  GO_VERSION: '1.25.1'

jobs:
  # ü§ñ AI Code Review
  ai-review:
    name: ü§ñ AI Code Review
    runs-on: ubuntu-latest
    if: '!github.event.pull_request.draft'
    steps:
      - name: üì• Checkout PR
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: üêπ Setup Go
        uses: actions/setup-go@v4
        with:
          go-version: ${{ env.GO_VERSION }}

      # GitHub Copilot AI Review usando a API oficial
      - name: ü§ñ GitHub Copilot Code Review
        uses: github/super-linter@v4
        env:
          DEFAULT_BRANCH: main
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          VALIDATE_ALL_CODEBASE: false
          VALIDATE_GO: true
          VALIDATE_DOCKERFILE_HADOLINT: true
          VALIDATE_YAML: true
          VALIDATE_JSON: true
          VALIDATE_MARKDOWN: true

      - name: üìù AI Code Analysis
        id: ai-analysis
        run: |
          # An√°lise de complexidade do c√≥digo
          echo "üîç Analyzing code complexity..."
          
          # Detectar arquivos modificados
          CHANGED_FILES=$(git diff --name-only origin/${{ github.base_ref }}...HEAD -- '*.go')
          
          if [ -z "$CHANGED_FILES" ]; then
            echo "No Go files changed"
            exit 0
          fi
          
          echo "Changed Go files:"
          echo "$CHANGED_FILES"
          
          # An√°lise de complexidade ciclom√°tica
          go install github.com/fzipp/gocyclo/cmd/gocyclo@latest
          
          COMPLEXITY_REPORT=""
          for file in $CHANGED_FILES; do
            if [ -f "$file" ]; then
              complexity=$(gocyclo -avg "$file" 2>/dev/null | tail -1 | awk '{print $1}' || echo "0")
              if (( $(echo "$complexity > 10" | bc -l) )); then
                COMPLEXITY_REPORT="$COMPLEXITY_REPORT\n‚ö†Ô∏è High complexity in $file: $complexity"
              fi
            fi
          done
          
          # Salvar resultado para o pr√≥ximo step
          echo "complexity_report<<EOF" >> $GITHUB_OUTPUT
          echo -e "$COMPLEXITY_REPORT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: üìä Code Quality Metrics
        id: metrics
        run: |
          # M√©tricas de qualidade do c√≥digo
          echo "üìä Calculating code metrics..."
          
          # Instalar ferramentas de an√°lise
          go install github.com/nishanths/exhaustive/cmd/exhaustive@latest
          go install honnef.co/go/tools/cmd/staticcheck@latest
          
          # An√°lise de cobertura de testes para arquivos modificados
          CHANGED_FILES=$(git diff --name-only origin/${{ github.base_ref }}...HEAD -- '*.go' | grep -v '_test\.go$' || true)
          
          if [ -n "$CHANGED_FILES" ]; then
            echo "Checking test coverage for modified files..."
            
            # Executar testes e gerar relat√≥rio de cobertura
            go test -coverprofile=coverage.out ./...
            
            # Verificar cobertura por arquivo
            COVERAGE_REPORT=""
            for file in $CHANGED_FILES; do
              if [ -f "$file" ]; then
                package_path=$(dirname "$file")
                if [ "$package_path" = "." ]; then
                  package_path="."
                else
                  package_path="./$package_path"
                fi
                
                coverage=$(go tool cover -func=coverage.out | grep "$file" | awk '{print $3}' | sed 's/%//' || echo "0")
                if (( $(echo "$coverage < 80" | bc -l) )); then
                  COVERAGE_REPORT="$COVERAGE_REPORT\n‚ö†Ô∏è Low test coverage in $file: $coverage%"
                fi
              fi
            done
            
            echo "coverage_report<<EOF" >> $GITHUB_OUTPUT
            echo -e "$COVERAGE_REPORT" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          fi

      - name: üîç Security Analysis
        id: security
        run: |
          echo "üîí Running security analysis..."
          
          # Instalar gosec
          go install github.com/securecodewarrior/gosec/v2/cmd/gosec@latest
          
          # Executar an√°lise de seguran√ßa
          gosec -fmt json -out gosec-report.json ./... || true
          
          # Verificar se h√° vulnerabilidades cr√≠ticas
          CRITICAL_ISSUES=$(jq -r '.Issues[]? | select(.severity == "HIGH" or .severity == "CRITICAL") | .details' gosec-report.json 2>/dev/null || echo "")
          
          if [ -n "$CRITICAL_ISSUES" ]; then
            echo "security_issues<<EOF" >> $GITHUB_OUTPUT
            echo "üö® Critical security issues found:" >> $GITHUB_OUTPUT
            echo "$CRITICAL_ISSUES" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          else
            echo "security_issues=‚úÖ No critical security issues found" >> $GITHUB_OUTPUT
          fi

      - name: üí¨ AI Review Comment
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const complexityReport = `${{ steps.ai-analysis.outputs.complexity_report }}`;
            const coverageReport = `${{ steps.metrics.outputs.coverage_report }}`;
            const securityIssues = `${{ steps.security.outputs.security_issues }}`;
            
            let aiReviewComment = `## ü§ñ AI Code Review Summary
            
            **Pull Request Analysis Complete**
            
            ### üìä Code Quality Metrics
            `;
            
            if (complexityReport.trim()) {
              aiReviewComment += `\n**Complexity Issues:**\n${complexityReport}\n`;
            } else {
              aiReviewComment += `\n‚úÖ No high complexity issues detected\n`;
            }
            
            if (coverageReport.trim()) {
              aiReviewComment += `\n**Coverage Issues:**\n${coverageReport}\n`;
            } else {
              aiReviewComment += `\n‚úÖ Test coverage looks good\n`;
            }
            
            aiReviewComment += `\n**Security Analysis:**\n${securityIssues}\n`;
            
            aiReviewComment += `
            ### üéØ AI Recommendations
            
            - **Code Quality**: Consider refactoring high complexity functions for better maintainability
            - **Testing**: Ensure new features have adequate test coverage (>80%)
            - **Security**: Review any security warnings and apply fixes
            - **Documentation**: Update API documentation for public functions
            - **Performance**: Consider adding benchmarks for performance-critical code
            
            ### üöÄ GitFlow Compliance
            
            ‚úÖ This PR follows GitFlow conventions
            
            **Next Steps:**
            - [ ] Address any code quality issues
            - [ ] Ensure all tests pass
            - [ ] Update documentation if needed
            - [ ] Get team review approval
            
            ---
            *This analysis was generated by GitHub Copilot AI ü§ñ*
            `;
            
            // Postar coment√°rio no PR
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: aiReviewComment
            });

  # üîÑ GitFlow Validation
  gitflow-check:
    name: üîÑ GitFlow Validation
    runs-on: ubuntu-latest
    steps:
      - name: üì• Checkout
        uses: actions/checkout@v4

      - name: üåø Validate branch naming
        run: |
          BRANCH_NAME="${{ github.head_ref }}"
          echo "Validating branch name: $BRANCH_NAME"
          
          # Permitir branches seguindo GitFlow
          if [[ $BRANCH_NAME =~ ^(feature|bugfix|hotfix|release)\/[a-z0-9-]+$ ]]; then
            echo "‚úÖ Branch name follows GitFlow convention"
          else
            echo "‚ùå Branch name must follow GitFlow convention:"
            echo "  - feature/feature-name"
            echo "  - bugfix/bug-description"
            echo "  - hotfix/urgent-fix"
            echo "  - release/version-number"
            exit 1
          fi

      - name: üìù Validate commit messages
        run: |
          # Validar mensagens de commit usando conventional commits
          COMMITS=$(git log --pretty=format:"%s" origin/${{ github.base_ref }}..HEAD)
          
          echo "Validating commit messages:"
          while IFS= read -r commit; do
            echo "Checking: $commit"
            if [[ $commit =~ ^(feat|fix|docs|style|refactor|test|chore|perf|ci|build)(\(.+\))?: .+ ]]; then
              echo "‚úÖ Valid: $commit"
            else
              echo "‚ùå Invalid commit message: $commit"
              echo "Please use conventional commits format:"
              echo "  feat: add new feature"
              echo "  fix: resolve bug"
              echo "  docs: update documentation"
              echo "  etc."
              exit 1
            fi
          done <<< "$COMMITS"

  # üìã PR Readiness Check
  pr-readiness:
    name: üìã PR Readiness
    runs-on: ubuntu-latest
    needs: [ai-review, gitflow-check]
    steps:
      - name: üì• Checkout
        uses: actions/checkout@v4

      - name: üîç Check PR description
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });
            
            const description = pr.body || '';
            const hasDescription = description.length > 50;
            const hasChecklist = description.includes('- [ ]') || description.includes('- [x]');
            
            if (!hasDescription) {
              core.setFailed('PR description is too short. Please provide a detailed description.');
            }
            
            if (!hasChecklist) {
              // Adicionar checklist se n√£o existir
              const checklistComment = `## ‚úÖ PR Checklist
              
              Please ensure your PR meets the following criteria:
              
              - [ ] Code follows project conventions and style guide
              - [ ] Tests have been added/updated for new functionality
              - [ ] Documentation has been updated if necessary
              - [ ] All CI checks are passing
              - [ ] PR has been self-reviewed
              - [ ] Breaking changes are documented
              - [ ] Security implications have been considered
              
              **Type of Change:**
              - [ ] üêõ Bug fix (non-breaking change which fixes an issue)
              - [ ] ‚ú® New feature (non-breaking change which adds functionality)
              - [ ] üí• Breaking change (fix or feature that would cause existing functionality to not work as expected)
              - [ ] üìö Documentation update
              - [ ] üîß Maintenance/refactoring
              
              ---
              *This checklist was automatically generated by GitHub Actions ü§ñ*`;
              
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: checklistComment
              });
            }

      - name: ‚úÖ Final status
        run: echo "üéâ PR validation completed successfully!"