
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>api: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/edalferes/monogo/cmd/api/main.go (0.0%)</option>
				
				<option value="file1">github.com/edalferes/monogo/docs/docs.go (0.0%)</option>
				
				<option value="file2">github.com/edalferes/monogo/internal/applications/api/app.go (0.0%)</option>
				
				<option value="file3">github.com/edalferes/monogo/internal/cli/cli.go (44.4%)</option>
				
				<option value="file4">github.com/edalferes/monogo/internal/config/config.go (0.0%)</option>
				
				<option value="file5">github.com/edalferes/monogo/internal/config/loader.go (0.0%)</option>
				
				<option value="file6">github.com/edalferes/monogo/internal/config/types.go (0.0%)</option>
				
				<option value="file7">github.com/edalferes/monogo/internal/config/validator.go (0.0%)</option>
				
				<option value="file8">github.com/edalferes/monogo/internal/infra/db/db.go (0.0%)</option>
				
				<option value="file9">github.com/edalferes/monogo/internal/modules/auth/adapters/http/handlers/admin/role_permission.go (0.0%)</option>
				
				<option value="file10">github.com/edalferes/monogo/internal/modules/auth/adapters/http/handlers/admin/user.go (0.0%)</option>
				
				<option value="file11">github.com/edalferes/monogo/internal/modules/auth/adapters/http/handlers/login/login.go (0.0%)</option>
				
				<option value="file12">github.com/edalferes/monogo/internal/modules/auth/adapters/http/middleware.go (0.0%)</option>
				
				<option value="file13">github.com/edalferes/monogo/internal/modules/auth/adapters/repository/gorm/audit_log_repository_gorm.go (0.0%)</option>
				
				<option value="file14">github.com/edalferes/monogo/internal/modules/auth/adapters/repository/gorm/permission_repository_gorm.go (0.0%)</option>
				
				<option value="file15">github.com/edalferes/monogo/internal/modules/auth/adapters/repository/gorm/role_repository_gorm.go (0.0%)</option>
				
				<option value="file16">github.com/edalferes/monogo/internal/modules/auth/adapters/repository/gorm/user_repository_gorm.go (0.0%)</option>
				
				<option value="file17">github.com/edalferes/monogo/internal/modules/auth/adapters/repository/mappers/audit_log_mapper.go (0.0%)</option>
				
				<option value="file18">github.com/edalferes/monogo/internal/modules/auth/adapters/repository/mappers/permission_mapper.go (0.0%)</option>
				
				<option value="file19">github.com/edalferes/monogo/internal/modules/auth/adapters/repository/mappers/role_mapper.go (0.0%)</option>
				
				<option value="file20">github.com/edalferes/monogo/internal/modules/auth/adapters/repository/mappers/user_mapper.go (0.0%)</option>
				
				<option value="file21">github.com/edalferes/monogo/internal/modules/auth/adapters/repository/models/audit_log_model.go (0.0%)</option>
				
				<option value="file22">github.com/edalferes/monogo/internal/modules/auth/adapters/repository/models/permission_model.go (0.0%)</option>
				
				<option value="file23">github.com/edalferes/monogo/internal/modules/auth/adapters/repository/models/role_model.go (0.0%)</option>
				
				<option value="file24">github.com/edalferes/monogo/internal/modules/auth/adapters/repository/models/user_model.go (0.0%)</option>
				
				<option value="file25">github.com/edalferes/monogo/internal/modules/auth/entities.go (0.0%)</option>
				
				<option value="file26">github.com/edalferes/monogo/internal/modules/auth/middleware_exports.go (0.0%)</option>
				
				<option value="file27">github.com/edalferes/monogo/internal/modules/auth/module.go (0.0%)</option>
				
				<option value="file28">github.com/edalferes/monogo/internal/modules/auth/seed.go (0.0%)</option>
				
				<option value="file29">github.com/edalferes/monogo/internal/modules/auth/service/audit_service.go (0.0%)</option>
				
				<option value="file30">github.com/edalferes/monogo/internal/modules/auth/service/jwt_service.go (0.0%)</option>
				
				<option value="file31">github.com/edalferes/monogo/internal/modules/auth/service/password_service.go (0.0%)</option>
				
				<option value="file32">github.com/edalferes/monogo/internal/modules/auth/usecase/permission/check_permission.go (0.0%)</option>
				
				<option value="file33">github.com/edalferes/monogo/internal/modules/auth/usecase/permission/create_permission.go (0.0%)</option>
				
				<option value="file34">github.com/edalferes/monogo/internal/modules/auth/usecase/permission/delete_permission.go (0.0%)</option>
				
				<option value="file35">github.com/edalferes/monogo/internal/modules/auth/usecase/permission/get_permission_by_id.go (0.0%)</option>
				
				<option value="file36">github.com/edalferes/monogo/internal/modules/auth/usecase/permission/list_permissions.go (0.0%)</option>
				
				<option value="file37">github.com/edalferes/monogo/internal/modules/auth/usecase/permission/update_permission.go (0.0%)</option>
				
				<option value="file38">github.com/edalferes/monogo/internal/modules/auth/usecase/role/create_role.go (0.0%)</option>
				
				<option value="file39">github.com/edalferes/monogo/internal/modules/auth/usecase/role/delete_role.go (0.0%)</option>
				
				<option value="file40">github.com/edalferes/monogo/internal/modules/auth/usecase/role/get_role_by_id.go (0.0%)</option>
				
				<option value="file41">github.com/edalferes/monogo/internal/modules/auth/usecase/role/list_roles.go (0.0%)</option>
				
				<option value="file42">github.com/edalferes/monogo/internal/modules/auth/usecase/role/update_role.go (0.0%)</option>
				
				<option value="file43">github.com/edalferes/monogo/internal/modules/auth/usecase/user/assign_role.go (0.0%)</option>
				
				<option value="file44">github.com/edalferes/monogo/internal/modules/auth/usecase/user/delete_user.go (0.0%)</option>
				
				<option value="file45">github.com/edalferes/monogo/internal/modules/auth/usecase/user/get_user_by_id.go (0.0%)</option>
				
				<option value="file46">github.com/edalferes/monogo/internal/modules/auth/usecase/user/list_users.go (0.0%)</option>
				
				<option value="file47">github.com/edalferes/monogo/internal/modules/auth/usecase/user/login.go (0.0%)</option>
				
				<option value="file48">github.com/edalferes/monogo/internal/modules/auth/usecase/user/login_with_audit.go (0.0%)</option>
				
				<option value="file49">github.com/edalferes/monogo/internal/modules/auth/usecase/user/register.go (0.0%)</option>
				
				<option value="file50">github.com/edalferes/monogo/internal/modules/auth/usecase/user/update_user.go (0.0%)</option>
				
				<option value="file51">github.com/edalferes/monogo/internal/modules/testmodule/adapters/http/handler/handler.go (0.0%)</option>
				
				<option value="file52">github.com/edalferes/monogo/internal/modules/testmodule/module.go (0.0%)</option>
				
				<option value="file53">github.com/edalferes/monogo/pkg/logger/config.go (0.0%)</option>
				
				<option value="file54">github.com/edalferes/monogo/pkg/logger/logger.go (0.0%)</option>
				
				<option value="file55">github.com/edalferes/monogo/pkg/logger/zerolog_logger.go (0.0%)</option>
				
				<option value="file56">github.com/edalferes/monogo/pkg/responses/responses.go (0.0%)</option>
				
				<option value="file57">github.com/edalferes/monogo/pkg/utils/ip.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        _ "github.com/edalferes/monogo/docs"
        "github.com/edalferes/monogo/internal/cli"
)

func main() <span class="cov0" title="0">{
        cli.ExecuteCLI()
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "contact": {},
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/v1/admin/permissions": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "tags": [
                    "admin"
                ],
                "summary": "List all permissions",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "type": "object",
                                "additionalProperties": true
                            }
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "tags": [
                    "admin"
                ],
                "summary": "Create a new permission",
                "parameters": [
                    {
                        "description": "Permission name",
                        "name": "permission",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/v1/admin/permissions/{name}": {
            "delete": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "tags": [
                    "admin"
                ],
                "summary": "Delete a permission",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Permission name",
                        "name": "name",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "204": {
                        "description": "No Content",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/v1/admin/roles": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "tags": [
                    "admin"
                ],
                "summary": "List all roles",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "type": "object",
                                "additionalProperties": true
                            }
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "tags": [
                    "admin"
                ],
                "summary": "Create a new role",
                "parameters": [
                    {
                        "description": "Role name",
                        "name": "role",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/v1/admin/roles/{name}": {
            "delete": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "tags": [
                    "admin"
                ],
                "summary": "Delete a role",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Role name",
                        "name": "name",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "204": {
                        "description": "No Content",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/v1/admin/users": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "admin"
                ],
                "summary": "List all users",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/domain.User"
                            }
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "admin"
                ],
                "summary": "Create a new user",
                "parameters": [
                    {
                        "description": "User data",
                        "name": "user",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dto.RegisterDTO"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "created",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "400": {
                        "description": "invalid data or user exists",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "500": {
                        "description": "internal error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/v1/auth/login": {
            "post": {
                "description": "Authenticates user and returns JWT token",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "summary": "User login",
                "parameters": [
                    {
                        "description": "User credentials",
                        "name": "credentials",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dto.LoginDTO"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "token",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "400": {
                        "description": "invalid data or missing credentials",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "401": {
                        "description": "invalid credentials",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "500": {
                        "description": "internal error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/v1/test/protected": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "tags": [
                    "testmodule"
                ],
                "summary": "Protected endpoint for testing roles/permissions",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "403": {
                        "description": "Forbidden",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "domain.Permission": {
            "type": "object",
            "properties": {
                "id": {
                    "description": "Unique identifier",
                    "type": "integer"
                },
                "name": {
                    "description": "Unique permission name (resource:action format)",
                    "type": "string"
                }
            }
        },
        "domain.Role": {
            "type": "object",
            "properties": {
                "id": {
                    "description": "Unique identifier",
                    "type": "integer"
                },
                "name": {
                    "description": "Unique role name",
                    "type": "string"
                },
                "permissions": {
                    "description": "Associated permissions",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/domain.Permission"
                    }
                }
            }
        },
        "domain.User": {
            "type": "object",
            "properties": {
                "id": {
                    "description": "Unique identifier",
                    "type": "integer"
                },
                "roles": {
                    "description": "Associated roles for authorization",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/domain.Role"
                    }
                },
                "username": {
                    "description": "Unique username for login",
                    "type": "string"
                }
            }
        },
        "dto.LoginDTO": {
            "type": "object",
            "required": [
                "password",
                "username"
            ],
            "properties": {
                "password": {
                    "type": "string"
                },
                "username": {
                    "type": "string"
                }
            }
        },
        "dto.RegisterDTO": {
            "type": "object",
            "required": [
                "password",
                "username"
            ],
            "properties": {
                "password": {
                    "type": "string"
                },
                "username": {
                    "type": "string"
                }
            }
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "",
        Host:             "",
        BasePath:         "",
        Schemes:          []string{},
        Title:            "",
        Description:      "",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
        LeftDelim:        "{{",
        RightDelim:       "}}",
}

func init() <span class="cov0" title="0">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package api

import (
        "fmt"

        "github.com/edalferes/monogo/internal/config"
        "github.com/edalferes/monogo/internal/infra/db"
        "github.com/edalferes/monogo/internal/modules/auth"
        "github.com/edalferes/monogo/internal/modules/testmodule"
        "github.com/edalferes/monogo/pkg/logger"
        "github.com/labstack/echo/v4"
        echoSwagger "github.com/swaggo/echo-swagger"
        "gorm.io/gorm"
)

type App struct {
        echo    *echo.Echo
        db      *gorm.DB
        logger  logger.Logger
        modules []string // modules to load
}

func NewApp() *App <span class="cov0" title="0">{
        cfg := config.LoadConfig()

        // Configure logger based on configuration
        loggerConfig := logger.DefaultConfig()
        loggerConfig.Level = cfg.Logger.Level
        loggerConfig.Format = cfg.Logger.Format
        loggerConfig.Service = cfg.App.Name

        appLogger := logger.New(loggerConfig)
        database, err := db.NewGormDB(cfg)
        if err != nil </span><span class="cov0" title="0">{
                appLogger.Fatal().Err(err).Msg("failed to connect to database")
        }</span>

        <span class="cov0" title="0">var entities []interface{}
        entities = append(entities, auth.Entities()...)
        if err := database.AutoMigrate(entities...); err != nil </span><span class="cov0" title="0">{
                appLogger.Fatal().Err(err).Msg("failed to migrate database")
        }</span>
        // Seed roles default
        <span class="cov0" title="0">if err := auth.Seed(database); err != nil </span><span class="cov0" title="0">{
                appLogger.Fatal().Err(err).Msg("failed to seed roles")
        }</span>

        <span class="cov0" title="0">e := echo.New()
        return &amp;App{
                echo:    e,
                db:      database,
                logger:  appLogger,
                modules: []string{"auth", "testmodule"}, // default all modules
        }</span>
}

// NewAppWithModules creates an app instance with specific modules
func NewAppWithModules(modules []string) *App <span class="cov0" title="0">{
        cfg := config.LoadConfig()

        // Configure logger based on configuration
        loggerConfig := logger.DefaultConfig()
        loggerConfig.Level = cfg.Logger.Level
        loggerConfig.Format = cfg.Logger.Format
        loggerConfig.Service = cfg.App.Name

        appLogger := logger.New(loggerConfig)
        database, err := db.NewGormDB(cfg)
        if err != nil </span><span class="cov0" title="0">{
                appLogger.Fatal().Err(err).Msg("failed to connect to database")
        }</span>

        // Only migrate entities for enabled modules
        <span class="cov0" title="0">var entities []interface{}
        for _, module := range modules </span><span class="cov0" title="0">{
                switch module </span>{
                case "auth":<span class="cov0" title="0">
                        entities = append(entities, auth.Entities()...)</span>
                }
        }

        <span class="cov0" title="0">if len(entities) &gt; 0 </span><span class="cov0" title="0">{
                if err := database.AutoMigrate(entities...); err != nil </span><span class="cov0" title="0">{
                        appLogger.Fatal().Err(err).Msg("failed to migrate database")
                }</span>
        }

        // Seed only if auth module is enabled
        <span class="cov0" title="0">for _, module := range modules </span><span class="cov0" title="0">{
                if module == "auth" </span><span class="cov0" title="0">{
                        if err := auth.Seed(database); err != nil </span><span class="cov0" title="0">{
                                appLogger.Fatal().Err(err).Msg("failed to seed roles")
                        }</span>
                        <span class="cov0" title="0">break</span>
                }
        }

        <span class="cov0" title="0">e := echo.New()
        return &amp;App{
                echo:    e,
                db:      database,
                logger:  appLogger,
                modules: modules,
        }</span>
}

// RegisterModules register enabled modules
func (a *App) RegisterModules(cfg *config.Config) <span class="cov0" title="0">{
        v1 := a.echo.Group("/v1")

        // Register only enabled modules
        for _, module := range a.modules </span><span class="cov0" title="0">{
                switch module </span>{
                case "auth":<span class="cov0" title="0">
                        a.logger.Info().Str("module", "auth").Msg("Registering auth module")
                        auth.WireUp(v1, a.db, cfg.JWT.Secret, a.logger)</span>
                case "testmodule":<span class="cov0" title="0">
                        a.logger.Info().Str("module", "testmodule").Msg("Registering test module")
                        testmodule.WireUp(v1, cfg.JWT.Secret)</span>
                default:<span class="cov0" title="0">
                        a.logger.Warn().Str("module", module).Msg("Unknown module, skipping")</span>
                }
        }
}

func (a *App) RegisterGlobalRoutes() <span class="cov0" title="0">{
        a.echo.GET("/health", func(c echo.Context) error </span><span class="cov0" title="0">{
                return c.String(200, "ok")
        }</span>)
        <span class="cov0" title="0">a.echo.GET("/metrics", func(c echo.Context) error </span><span class="cov0" title="0">{
                return c.String(200, "metrics: not implemented")
        }</span>)
        <span class="cov0" title="0">a.echo.GET("/swagger/*", echoSwagger.WrapHandler)</span>
}

func (a *App) Run(cfg *config.Config) <span class="cov0" title="0">{
        a.RegisterGlobalRoutes()
        a.RegisterModules(cfg)
        a.logger.Info().
                Int("port", cfg.App.Port).
                Str("env", cfg.App.Environment).
                Str("modules", fmt.Sprintf("%v", a.modules)).
                Msg("Starting API server")
        a.echo.Logger.Fatal(a.echo.Start(fmt.Sprintf(":%d", cfg.App.Port)))
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">// Package cli provides command-line interface functionality for the modular application.
//
// This package implements a clean CLI architecture using Cobra that allows selective
// module execution, following the Single Responsibility Principle and maintaining
// clear separation of concerns.
package cli

import (
        "fmt"
        "os"
        "strings"

        "github.com/edalferes/monogo/internal/applications/api"
        "github.com/edalferes/monogo/internal/config"
        "github.com/spf13/cobra"
)

// ModuleRunner defines the contract for running the application with specific modules.
// This interface follows the Dependency Inversion Principle, allowing easy testing
// and different implementations.
type ModuleRunner interface {
        RunWithModules(modules []string, cfg *config.Config) error
}

// AppRunner implements ModuleRunner using the actual application.
type AppRunner struct{}

// RunWithModules starts the application with the specified modules.
func (r *AppRunner) RunWithModules(modules []string, cfg *config.Config) error <span class="cov0" title="0">{
        app := api.NewAppWithModules(modules)
        app.Run(cfg)
        return nil
}</span>

// CLI encapsulates the command-line interface functionality.
type CLI struct {
        runner ModuleRunner
        config *config.Config
}

// NewCLI creates a new CLI instance with clean dependencies.
func NewCLI() *CLI <span class="cov3" title="3">{
        return &amp;CLI{
                runner: &amp;AppRunner{},
                config: config.LoadConfig(),
        }
}</span>

// NewCLIWithRunner creates a CLI instance with a custom runner (useful for testing).
func NewCLIWithRunner(runner ModuleRunner, cfg *config.Config) *CLI <span class="cov2" title="2">{
        return &amp;CLI{
                runner: runner,
                config: cfg,
        }
}</span>

// Execute runs the CLI application.
func (c *CLI) Execute() error <span class="cov0" title="0">{
        return c.createRootCommand().Execute()
}</span>

// createRootCommand builds the root cobra command with clean configuration.
func (c *CLI) createRootCommand() *cobra.Command <span class="cov0" title="0">{
        var modules []string

        rootCmd := &amp;cobra.Command{
                Use:     "monogo",
                Short:   "Modular monolith application with selective module execution",
                Long:    c.getLongDescription(),
                Example: c.getExamples(),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.runApplication(modules)
                }</span>,
        }

        // Configure flags with clean defaults
        <span class="cov0" title="0">rootCmd.Flags().StringSliceVarP(
                &amp;modules,
                "modules",
                "m",
                []string{"auth", "testmodule"},
                "Modules to run (auth, testmodule)",
        )

        // Add subcommands
        rootCmd.AddCommand(c.createListCommand())
        rootCmd.AddCommand(c.createHealthCommand())

        return rootCmd</span>
}

// runApplication executes the main application logic.
func (c *CLI) runApplication(modules []string) error <span class="cov1" title="1">{
        validModules := c.validateAndCleanModules(modules)

        fmt.Printf("üöÄ Starting Monogo with modules: %s\n",
                strings.Join(validModules, ", "))

        return c.runner.RunWithModules(validModules, c.config)
}</span>

// validateAndCleanModules ensures only valid modules are processed.
func (c *CLI) validateAndCleanModules(modules []string) []string <span class="cov6" title="7">{
        validModules := []string{"auth", "testmodule"}
        var result []string

        for _, module := range modules </span><span class="cov7" title="12">{
                module = strings.TrimSpace(strings.ToLower(module))
                if c.isValidModule(module, validModules) </span><span class="cov6" title="9">{
                        result = append(result, module)
                }</span> else<span class="cov3" title="3"> {
                        fmt.Printf("‚ö†Ô∏è  Unknown module '%s', skipping\n", module)
                }</span>
        }

        <span class="cov6" title="7">if len(result) == 0 </span><span class="cov2" title="2">{
                fmt.Println("‚ö†Ô∏è  No valid modules specified, using default: auth")
                return []string{"auth"}
        }</span>

        <span class="cov5" title="5">return result</span>
}

// isValidModule checks if a module is in the list of valid modules.
func (c *CLI) isValidModule(module string, validModules []string) bool <span class="cov8" title="19">{
        for _, valid := range validModules </span><span class="cov10" title="32">{
                if module == valid </span><span class="cov7" title="11">{
                        return true
                }</span>
        }
        <span class="cov6" title="8">return false</span>
}

// createListCommand creates a command to list available modules.
func (c *CLI) createListCommand() *cobra.Command <span class="cov0" title="0">{
        return &amp;cobra.Command{
                Use:   "list",
                Short: "List available modules",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        fmt.Println("üì¶ Available modules:")
                        fmt.Println("  ‚Ä¢ auth      - Authentication and authorization")
                        fmt.Println("  ‚Ä¢ testmodule - Test and development module")
                }</span>,
        }
}

// createHealthCommand creates a health check command.
func (c *CLI) createHealthCommand() *cobra.Command <span class="cov0" title="0">{
        return &amp;cobra.Command{
                Use:   "health",
                Short: "Check application health",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        fmt.Println("‚úÖ Application is healthy")
                        fmt.Printf("üìç Environment: %s\n", c.config.App.Environment)
                        fmt.Printf("üîß Version: %s\n", c.config.App.Name)
                }</span>,
        }
}

// getLongDescription returns the detailed description for the CLI.
func (c *CLI) getLongDescription() string <span class="cov0" title="0">{
        return `Monogo is a modular monolith application that supports selective module execution.

This allows you to run specific modules independently, enabling microservice-like 
deployment patterns while maintaining the benefits of a monolithic codebase.

Each module can be deployed as a separate service using the same binary and Docker image,
providing flexibility in scaling and deployment strategies.`
}</span>

// getExamples returns usage examples for the CLI.
func (c *CLI) getExamples() string <span class="cov0" title="0">{
        return `  # Run with default auth module
  monogo

  # Run specific modules
  monogo --modules auth,testmodule
  monogo -m testmodule

  # List available modules
  monogo list

  # Check application health
  monogo health`
}</span>

// ExecuteCLI is the main entry point for the CLI application.
// This function provides a clean interface for main.go.
func ExecuteCLI() <span class="cov0" title="0">{
        cli := NewCLI()
        if err := cli.Execute(); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("‚ùå Error: %v\n", err)
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package config

import (
        "fmt"
        "os"
)

// Load loads configuration with validation
func Load(opts ...LoadOptions) (*Config, error) <span class="cov0" title="0">{
        loader := NewLoader()
        validator := NewValidator()

        config, err := loader.Load(opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := validator.Validate(config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid configuration: %w", err)
        }</span>

        <span class="cov0" title="0">return config, nil</span>
}

// LoadConfig loads configuration with default options (for compatibility)
func LoadConfig() *Config <span class="cov0" title="0">{
        config, err := Load()
        if err != nil </span><span class="cov0" title="0">{
                // Fallback to old behavior if fails
                fmt.Printf("Error loading configuration: %v\n", err)
                fmt.Println("Using fallback to environment variables...")
                return loadFromEnvOnly()
        }</span>
        <span class="cov0" title="0">return config</span>
}

// loadFromEnvOnly loads only from environment variables (fallback)
func loadFromEnvOnly() *Config <span class="cov0" title="0">{
        return &amp;Config{
                App: AppConfig{
                        Name:        getEnvOrDefault("APP_NAME", "monogo"),
                        Version:     getEnvOrDefault("APP_VERSION", "1.0.0"),
                        Environment: getEnvOrDefault("APP_ENVIRONMENT", "development"),
                        Port:        getIntEnvOrDefault("PORT", 8080),
                },
                Database: DatabaseConfig{
                        Host:     os.Getenv("DB_HOST"),
                        Port:     getIntEnvOrDefault("DB_PORT", 5432),
                        User:     os.Getenv("DB_USER"),
                        Password: os.Getenv("DB_PASSWORD"),
                        Name:     os.Getenv("DB_NAME"),
                        SSLMode:  getEnvOrDefault("DB_SSL_MODE", "disable"),
                },
                JWT: JWTConfig{
                        Secret:     os.Getenv("JWT_SECRET"),
                        ExpiryHour: getIntEnvOrDefault("JWT_EXPIRY_HOUR", 24),
                },
                Logger: LoggerConfig{
                        Level:  getEnvOrDefault("LOG_LEVEL", "info"),
                        Format: getEnvOrDefault("LOG_FORMAT", "json"),
                },
        }
}</span>

func getEnvOrDefault(key, defaultValue string) string <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}

func getIntEnvOrDefault(key string, defaultValue int) int <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                if intValue := parseInt(value); intValue &gt; 0 </span><span class="cov0" title="0">{
                        return intValue
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}

func parseInt(s string) int <span class="cov0" title="0">{
        var result int
        fmt.Sscanf(s, "%d", &amp;result)
        return result
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package config

import (
        "fmt"
        "strings"

        "github.com/spf13/viper"
)

// LoadOptions options for loading configuration
type LoadOptions struct {
        ConfigPath string
        ConfigName string
        ConfigType string
}

// DefaultLoadOptions returns default options
func DefaultLoadOptions() LoadOptions <span class="cov0" title="0">{
        return LoadOptions{
                ConfigPath: ".",
                ConfigName: "config",
                ConfigType: "yaml",
        }
}</span>

// Loader is responsible for loading configurations
type Loader struct {
        viper *viper.Viper
}

// NewLoader creates a new configuration loader
func NewLoader() *Loader <span class="cov0" title="0">{
        return &amp;Loader{
                viper: viper.New(),
        }
}</span>

// Load loads configuration from YAML files and environment variables
func (l *Loader) Load(opts ...LoadOptions) (*Config, error) <span class="cov0" title="0">{
        options := DefaultLoadOptions()
        if len(opts) &gt; 0 </span><span class="cov0" title="0">{
                options = opts[0]
        }</span>

        // Configure search for configuration files
        <span class="cov0" title="0">l.viper.SetConfigName(options.ConfigName)
        l.viper.SetConfigType(options.ConfigType)
        l.viper.AddConfigPath(options.ConfigPath)
        l.viper.AddConfigPath("./config")
        l.viper.AddConfigPath(".")

        // Set default values
        l.setDefaults()

        // Configure reading of environment variables
        l.viper.AutomaticEnv()
        l.viper.SetEnvKeyReplacer(strings.NewReplacer(".", "_"))

        // Try to read configuration file
        if err := l.viper.ReadInConfig(); err != nil </span><span class="cov0" title="0">{
                if _, ok := err.(viper.ConfigFileNotFoundError); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error reading configuration file: %w", err)
                }</span>
                // If file not found, use only env vars and defaults
        }

        <span class="cov0" title="0">var config Config
        if err := l.viper.Unmarshal(&amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error unmarshaling configuration: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;config, nil</span>
}

// setDefaults sets default values
func (l *Loader) setDefaults() <span class="cov0" title="0">{
        // App defaults
        l.viper.SetDefault("app.name", "monogo")
        l.viper.SetDefault("app.version", "1.0.0")
        l.viper.SetDefault("app.environment", "development")
        l.viper.SetDefault("app.port", 8080)

        // Database defaults
        l.viper.SetDefault("database.host", "localhost")
        l.viper.SetDefault("database.port", 5432)
        l.viper.SetDefault("database.ssl_mode", "disable")

        // JWT defaults
        l.viper.SetDefault("jwt.expiry_hour", 24)

        // Logger defaults
        l.viper.SetDefault("logger.level", "info")
        l.viper.SetDefault("logger.format", "json")
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package config

import "fmt"

// Config represents the complete application configuration
type Config struct {
        App      AppConfig      `mapstructure:"app" yaml:"app"`
        Database DatabaseConfig `mapstructure:"database" yaml:"database"`
        JWT      JWTConfig      `mapstructure:"jwt" yaml:"jwt"`
        Logger   LoggerConfig   `mapstructure:"logger" yaml:"logger"`
}

// AppConfig application configuration
type AppConfig struct {
        Name        string `mapstructure:"name" yaml:"name"`
        Version     string `mapstructure:"version" yaml:"version"`
        Environment string `mapstructure:"environment" yaml:"environment"`
        Port        int    `mapstructure:"port" yaml:"port"`
}

// DatabaseConfig database configuration
type DatabaseConfig struct {
        Host     string `mapstructure:"host" yaml:"host"`
        Port     int    `mapstructure:"port" yaml:"port"`
        User     string `mapstructure:"user" yaml:"user"`
        Password string `mapstructure:"password" yaml:"password"`
        Name     string `mapstructure:"name" yaml:"name"`
        SSLMode  string `mapstructure:"ssl_mode" yaml:"ssl_mode"`
}

// JWTConfig JWT configuration
type JWTConfig struct {
        Secret     string `mapstructure:"secret" yaml:"secret"`
        ExpiryHour int    `mapstructure:"expiry_hour" yaml:"expiry_hour"`
}

// LoggerConfig logger configuration
type LoggerConfig struct {
        Level  string `mapstructure:"level" yaml:"level"`
        Format string `mapstructure:"format" yaml:"format"`
}

// Utility methods for Config

// GetDSN returns the database connection string
func (c *Config) GetDSN() string <span class="cov0" title="0">{
        return fmt.Sprintf(
                "host=%s port=%d user=%s password=%s dbname=%s sslmode=%s",
                c.Database.Host,
                c.Database.Port,
                c.Database.User,
                c.Database.Password,
                c.Database.Name,
                c.Database.SSLMode,
        )
}</span>

// IsDevelopment checks if running in development environment
func (c *Config) IsDevelopment() bool <span class="cov0" title="0">{
        return c.App.Environment == "development"
}</span>

// IsProduction checks if running in production environment
func (c *Config) IsProduction() bool <span class="cov0" title="0">{
        return c.App.Environment == "production"
}</span>

// IsStaging checks if running in staging environment
func (c *Config) IsStaging() bool <span class="cov0" title="0">{
        return c.App.Environment == "staging"
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package config

import (
        "fmt"
        "strings"
)

// Validator is responsible for validating configurations
type Validator struct{}

// NewValidator creates a new validator
func NewValidator() *Validator <span class="cov0" title="0">{
        return &amp;Validator{}
}</span>

// Validate checks if the configuration has the required fields
func (v *Validator) Validate(config *Config) error <span class="cov0" title="0">{
        if config.Database.Host == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("database.host is required")
        }</span>
        <span class="cov0" title="0">if config.Database.User == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("database.user is required")
        }</span>
        <span class="cov0" title="0">if config.Database.Name == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("database.name is required")
        }</span>
        <span class="cov0" title="0">if config.JWT.Secret == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("jwt.secret is required")
        }</span>
        <span class="cov0" title="0">if config.App.Port &lt;= 0 || config.App.Port &gt; 65535 </span><span class="cov0" title="0">{
                return fmt.Errorf("app.port must be between 1 and 65535")
        }</span>

        // Validate environment
        <span class="cov0" title="0">validEnvs := []string{"development", "staging", "production"}
        found := false
        for _, env := range validEnvs </span><span class="cov0" title="0">{
                if config.App.Environment == env </span><span class="cov0" title="0">{
                        found = true
                        break</span>
                }
        }
        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                return fmt.Errorf("app.environment must be one of: %s", strings.Join(validEnvs, ", "))
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package db

import (
        "gorm.io/driver/postgres"
        "gorm.io/gorm"

        "github.com/edalferes/monogo/internal/config"

        _ "github.com/lib/pq"
)

// NewGormDB Initialize a new Gorm DB connection
func NewGormDB(cfg *config.Config) (*gorm.DB, error) <span class="cov0" title="0">{
        dsn := cfg.GetDSN()
        return gorm.Open(postgres.Open(dsn), &amp;gorm.Config{})
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package admin

import (
        "net/http"

        "github.com/edalferes/monogo/internal/modules/auth/domain"
        "github.com/labstack/echo/v4"
)

type AdminHandler struct {
        ListRolesUC  interface{ Execute() ([]domain.Role, error) }
        CreateRoleUC interface {
                Execute(name string, permissionIDs []uint) error
        }
        DeleteRoleUC      interface{ Execute(name string) error }
        ListPermissionsUC interface {
                Execute() ([]domain.Permission, error)
        }
        CreatePermissionUC interface{ Execute(name string) error }
        DeletePermissionUC interface{ Execute(name string) error }
}

// ListRoles godoc
// @Summary List all roles
// @Tags admin
// @Security BearerAuth
// @Success 200 {array} map[string]interface{}
// @Router /v1/admin/roles [get]
func (h *AdminHandler) ListRoles(c echo.Context) error <span class="cov0" title="0">{
        roles, err := h.ListRolesUC.Execute()
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusInternalServerError, map[string]string{"error": err.Error()})
        }</span>
        <span class="cov0" title="0">return c.JSON(http.StatusOK, roles)</span>
}

// CreateRole godoc
// @Summary Create a new role
// @Tags admin
// @Security BearerAuth
// @Param role body map[string]string true "Role name"
// @Success 201 {object} map[string]string
// @Router /v1/admin/roles [post]
func (h *AdminHandler) CreateRole(c echo.Context) error <span class="cov0" title="0">{
        var req map[string]string
        if err := c.Bind(&amp;req); err != nil || req["name"] == "" </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, map[string]string{"error": "invalid role name"})
        }</span>
        // permissionIDs pode ser extra√≠do do body se necess√°rio
        <span class="cov0" title="0">if err := h.CreateRoleUC.Execute(req["name"], nil); err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusInternalServerError, map[string]string{"error": err.Error()})
        }</span>
        <span class="cov0" title="0">return c.JSON(http.StatusCreated, map[string]string{"message": "role created"})</span>
}

// DeleteRole godoc
// @Summary Delete a role
// @Tags admin
// @Security BearerAuth
// @Param name path string true "Role name"
// @Success 204 {object} map[string]string
// @Router /v1/admin/roles/{name} [delete]
func (h *AdminHandler) DeleteRole(c echo.Context) error <span class="cov0" title="0">{
        name := c.Param("name")
        if err := h.DeleteRoleUC.Execute(name); err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusInternalServerError, map[string]string{"error": err.Error()})
        }</span>
        <span class="cov0" title="0">return c.NoContent(http.StatusNoContent)</span>
}

// ListPermissions godoc
// @Summary List all permissions
// @Tags admin
// @Security BearerAuth
// @Success 200 {array} map[string]interface{}
// @Router /v1/admin/permissions [get]
func (h *AdminHandler) ListPermissions(c echo.Context) error <span class="cov0" title="0">{
        perms, err := h.ListPermissionsUC.Execute()
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusInternalServerError, map[string]string{"error": err.Error()})
        }</span>
        <span class="cov0" title="0">return c.JSON(http.StatusOK, perms)</span>
}

// CreatePermission godoc
// @Summary Create a new permission
// @Tags admin
// @Security BearerAuth
// @Param permission body map[string]string true "Permission name"
// @Success 201 {object} map[string]string
// @Router /v1/admin/permissions [post]
func (h *AdminHandler) CreatePermission(c echo.Context) error <span class="cov0" title="0">{
        var req map[string]string
        if err := c.Bind(&amp;req); err != nil || req["name"] == "" </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, map[string]string{"error": "invalid permission name"})
        }</span>
        <span class="cov0" title="0">if err := h.CreatePermissionUC.Execute(req["name"]); err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusInternalServerError, map[string]string{"error": err.Error()})
        }</span>
        <span class="cov0" title="0">return c.JSON(http.StatusCreated, map[string]string{"message": "permission created"})</span>
}

// DeletePermission godoc
// @Summary Delete a permission
// @Tags admin
// @Security BearerAuth
// @Param name path string true "Permission name"
// @Success 204 {object} map[string]string
// @Router /v1/admin/permissions/{name} [delete]
func (h *AdminHandler) DeletePermission(c echo.Context) error <span class="cov0" title="0">{
        name := c.Param("name")
        if err := h.DeletePermissionUC.Execute(name); err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusInternalServerError, map[string]string{"error": err.Error()})
        }</span>
        <span class="cov0" title="0">return c.NoContent(http.StatusNoContent)</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package admin

import (
        "net/http"

        "github.com/edalferes/monogo/internal/modules/auth/adapters/http/dto"
        "github.com/edalferes/monogo/internal/modules/auth/domain"
        "github.com/edalferes/monogo/internal/modules/auth/errors"
        "github.com/go-playground/validator/v10"
        "github.com/labstack/echo/v4"
)

type AdminUserHandler struct {
        ListUsersUC  interface{ Execute() ([]domain.User, error) }
        CreateUserUC interface {
                Execute(username, password string) error
        }
        // Add other use cases as needed (GetUserByIDUC, UpdateUserUC, DeleteUserUC)
}

// ListUsers godoc
// @Summary List all users
// @Tags admin
// @Security BearerAuth
// @Produce json
// @Success 200 {array} domain.User
// @Router /v1/admin/users [get]
func (h *AdminUserHandler) ListUsers(c echo.Context) error <span class="cov0" title="0">{
        users, err := h.ListUsersUC.Execute()
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusInternalServerError, map[string]string{"error": err.Error()})
        }</span>
        <span class="cov0" title="0">return c.JSON(http.StatusOK, users)</span>
}

// CreateUser godoc
// @Summary Create a new user
// @Tags admin
// @Security BearerAuth
// @Accept json
// @Produce json
// @Param user body dto.RegisterDTO true "User data"
// @Success 201 {object} map[string]string "created"
// @Failure 400 {object} map[string]string "invalid data or user exists"
// @Failure 500 {object} map[string]string "internal error"
// @Router /v1/admin/users [post]
func (h *AdminUserHandler) CreateUser(c echo.Context) error <span class="cov0" title="0">{
        var input dto.RegisterDTO
        if err := c.Bind(&amp;input); err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, map[string]string{"error": errors.ErrInvalidData.Error()})
        }</span>
        <span class="cov0" title="0">if err := validator.New().Struct(input); err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, map[string]string{"error": errors.ErrMissingCredentials.Error()})
        }</span>
        <span class="cov0" title="0">if err := h.CreateUserUC.Execute(input.Username, input.Password); err != nil </span><span class="cov0" title="0">{
                if err == errors.ErrUserAlreadyExists </span><span class="cov0" title="0">{
                        return c.JSON(http.StatusBadRequest, map[string]string{"error": err.Error()})
                }</span>
                <span class="cov0" title="0">return c.JSON(http.StatusInternalServerError, map[string]string{"error": "internal error"})</span>
        }
        <span class="cov0" title="0">return c.JSON(http.StatusCreated, map[string]string{"message": "user created"})</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">// Package login provides HTTP handlers for user authentication endpoints.
//
// This package implements the HTTP adapter layer for authentication operations,
// specifically handling login requests and JWT token generation. It follows
// Clean Architecture principles by delegating business logic to use cases.
package login

import (
        "net/http"

        "github.com/edalferes/monogo/internal/modules/auth/adapters/http/dto"
        "github.com/edalferes/monogo/internal/modules/auth/errors"
        userUC "github.com/edalferes/monogo/internal/modules/auth/usecase/user"
        "github.com/edalferes/monogo/pkg/logger"
        "github.com/edalferes/monogo/pkg/utils"
        "github.com/labstack/echo/v4"
)

// Handler handles HTTP requests for user authentication.
//
// This handler is responsible for:
//   - Binding HTTP request data to DTOs
//   - Delegating business logic to appropriate use cases
//   - Converting use case results to HTTP responses
//   - Logging HTTP-layer events and errors
//   - Returning appropriate HTTP status codes
//
// The handler follows Clean Architecture principles by:
//   - Depending on use case interfaces, not implementations
//   - Converting between HTTP and domain models
//   - Handling HTTP-specific concerns (status codes, headers)
//   - Delegating all business logic to use cases
//
// Example usage:
//
//        handler := &amp;Handler{
//                LoginUseCase: loginUseCase,
//                Logger:       logger,
//        }
//
//        e.POST("/auth/login", handler.Login)
type Handler struct {
        LoginUseCase *userUC.LoginWithAuditUseCase // Use case for authentication logic
        Logger       logger.Logger                 // Logger for HTTP-layer events
}

// Login godoc
// @Summary User login
// @Description Authenticates user and returns JWT token
// @Tags auth
// @Accept json
// @Produce json
// @Param credentials body dto.LoginDTO true "User credentials"
// @Success 200 {object} map[string]string "token"
// @Failure 400 {object} map[string]string "invalid data or missing credentials"
// @Failure 401 {object} map[string]string "invalid credentials"
// @Failure 500 {object} map[string]string "internal error"
// @Router /v1/auth/login [post]
func (h *Handler) Login(c echo.Context) error <span class="cov0" title="0">{
        var input dto.LoginDTO
        if err := c.Bind(&amp;input); err != nil </span><span class="cov0" title="0">{
                h.Logger.Error().Err(err).Msg("failed to bind login request")
                return c.JSON(http.StatusBadRequest, map[string]string{"error": errors.ErrInvalidData.Error()})
        }</span>
        <span class="cov0" title="0">if input.Username == "" || input.Password == "" </span><span class="cov0" title="0">{
                h.Logger.Warn().Str("username", input.Username).Msg("login attempt with missing credentials")
                return c.JSON(http.StatusBadRequest, map[string]string{"error": errors.ErrMissingCredentials.Error()})
        }</span>
        <span class="cov0" title="0">ip := utils.ToIPv4(c.RealIP())
        h.Logger.Info().Str("username", input.Username).Str("ip", ip).Msg("login attempt")

        token, err := h.LoginUseCase.Execute(input.Username, input.Password, ip)
        if err != nil </span><span class="cov0" title="0">{
                if err == errors.ErrInvalidCredentials </span><span class="cov0" title="0">{
                        h.Logger.Warn().Str("username", input.Username).Str("ip", ip).Msg("invalid credentials")
                        return c.JSON(http.StatusUnauthorized, map[string]string{"error": err.Error()})
                }</span>
                <span class="cov0" title="0">h.Logger.Error().Err(err).Str("username", input.Username).Msg("internal error during login")
                return c.JSON(http.StatusInternalServerError, map[string]string{"error": "internal error"})</span>
        }

        <span class="cov0" title="0">h.Logger.Info().Str("username", input.Username).Str("ip", ip).Msg("successful login")
        return c.JSON(http.StatusOK, map[string]string{"token": token})</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package auth

import (
        "net/http"
        "strings"

        "github.com/golang-jwt/jwt/v5"
        "github.com/labstack/echo/v4"
)

// JWTMiddleware authenticates the JWT token and populates the claims in the Echo context
func JWTMiddleware(secret string) echo.MiddlewareFunc <span class="cov0" title="0">{
        return func(next echo.HandlerFunc) echo.HandlerFunc </span><span class="cov0" title="0">{
                return func(c echo.Context) error </span><span class="cov0" title="0">{
                        authHeader := c.Request().Header.Get("Authorization")
                        parts := strings.Fields(authHeader)
                        if len(parts) != 2 || strings.ToLower(parts[0]) != "bearer" </span><span class="cov0" title="0">{
                                c.Logger().Errorf("JWTMiddleware: missing or malformed Authorization header: %v", authHeader)
                                return c.JSON(http.StatusUnauthorized, map[string]string{"error": "missing token"})
                        }</span>
                        <span class="cov0" title="0">tokenStr := parts[1]
                        token, err := jwt.Parse(tokenStr, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                                return []byte(secret), nil
                        }</span>)
                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                c.Logger().Errorf("JWTMiddleware: token parse error: %v", err)
                                return c.JSON(http.StatusUnauthorized, map[string]string{"error": "invalid token: " + err.Error()})
                        }</span>
                        <span class="cov0" title="0">if !token.Valid </span><span class="cov0" title="0">{
                                c.Logger().Error("JWTMiddleware: token is not valid")
                                return c.JSON(http.StatusUnauthorized, map[string]string{"error": "invalid token"})
                        }</span>
                        <span class="cov0" title="0">claims, ok := token.Claims.(jwt.MapClaims)
                        if !ok </span><span class="cov0" title="0">{
                                c.Logger().Error("JWTMiddleware: invalid claims type")
                                return c.JSON(http.StatusUnauthorized, map[string]string{"error": "invalid claims"})
                        }</span>
                        <span class="cov0" title="0">c.Set("user", claims)
                        return next(c)</span>
                }
        }
}

func RequireRoles(roles ...string) echo.MiddlewareFunc <span class="cov0" title="0">{
        return func(next echo.HandlerFunc) echo.HandlerFunc </span><span class="cov0" title="0">{
                return func(c echo.Context) error </span><span class="cov0" title="0">{
                        claims, ok := c.Get("user").(jwt.MapClaims)
                        if !ok </span><span class="cov0" title="0">{
                                return c.JSON(http.StatusForbidden, map[string]string{"error": "forbidden: no user claims"})
                        }</span>
                        <span class="cov0" title="0">userRoles, ok := claims["roles"].([]interface{})
                        if !ok </span><span class="cov0" title="0">{
                                return c.JSON(http.StatusForbidden, map[string]string{"error": "forbidden: no roles"})
                        }</span>
                        <span class="cov0" title="0">for _, required := range roles </span><span class="cov0" title="0">{
                                for _, ur := range userRoles </span><span class="cov0" title="0">{
                                        if roleStr, ok := ur.(string); ok &amp;&amp; roleStr == required </span><span class="cov0" title="0">{
                                                return next(c)
                                        }</span>
                                }
                        }
                        <span class="cov0" title="0">return c.JSON(http.StatusForbidden, map[string]string{"error": "forbidden: insufficient role"})</span>
                }
        }
}

func RequirePermissions(perms ...string) echo.MiddlewareFunc <span class="cov0" title="0">{
        return func(next echo.HandlerFunc) echo.HandlerFunc </span><span class="cov0" title="0">{
                return func(c echo.Context) error </span><span class="cov0" title="0">{
                        claims, ok := c.Get("user").(jwt.MapClaims)
                        if !ok </span><span class="cov0" title="0">{
                                return c.JSON(http.StatusForbidden, map[string]string{"error": "forbidden: no user claims"})
                        }</span>
                        <span class="cov0" title="0">userPerms, ok := claims["permissions"].([]interface{})
                        if !ok </span><span class="cov0" title="0">{
                                return c.JSON(http.StatusForbidden, map[string]string{"error": "forbidden: no permissions"})
                        }</span>
                        <span class="cov0" title="0">for _, required := range perms </span><span class="cov0" title="0">{
                                for _, up := range userPerms </span><span class="cov0" title="0">{
                                        if permStr, ok := up.(string); ok &amp;&amp; permStr == required </span><span class="cov0" title="0">{
                                                return next(c)
                                        }</span>
                                }
                        }
                        <span class="cov0" title="0">return c.JSON(http.StatusForbidden, map[string]string{"error": "forbidden: insufficient permission"})</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package gorm

import (
        "github.com/edalferes/monogo/internal/modules/auth/adapters/repository/mappers"
        "github.com/edalferes/monogo/internal/modules/auth/adapters/repository/models"
        "github.com/edalferes/monogo/internal/modules/auth/domain"
        "github.com/edalferes/monogo/internal/modules/auth/usecase/interfaces"
        gormpkg "gorm.io/gorm"
)

type AuditLogRepositoryGorm struct {
        DB     *gormpkg.DB
        mapper mappers.AuditLogMapper
}

func NewAuditLogRepositoryGorm(db *gormpkg.DB) *AuditLogRepositoryGorm <span class="cov0" title="0">{
        return &amp;AuditLogRepositoryGorm{
                DB:     db,
                mapper: mappers.AuditLogMapper{},
        }
}</span>

var _ interfaces.AuditLogRepository = (*AuditLogRepositoryGorm)(nil)

func (r *AuditLogRepositoryGorm) Create(log *domain.AuditLog) error <span class="cov0" title="0">{
        logModel := r.mapper.ToModel(*log)
        return r.DB.Create(&amp;logModel).Error
}</span>

func (r *AuditLogRepositoryGorm) ListAll() ([]domain.AuditLog, error) <span class="cov0" title="0">{
        var logModels []models.AuditLogModel
        if err := r.DB.Order("created_at desc").Find(&amp;logModels).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return r.mapper.ToDomainSlice(logModels), nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package gorm

import (
        "github.com/edalferes/monogo/internal/modules/auth/adapters/repository/mappers"
        "github.com/edalferes/monogo/internal/modules/auth/adapters/repository/models"
        "github.com/edalferes/monogo/internal/modules/auth/domain"
        "github.com/edalferes/monogo/internal/modules/auth/usecase/interfaces"
        gormpkg "gorm.io/gorm"
)

type PermissionRepositoryGorm struct {
        DB     *gormpkg.DB
        mapper mappers.PermissionMapper
}

func NewPermissionRepositoryGorm(db *gormpkg.DB) *PermissionRepositoryGorm <span class="cov0" title="0">{
        return &amp;PermissionRepositoryGorm{
                DB:     db,
                mapper: mappers.PermissionMapper{},
        }
}</span>

// Garantir que PermissionRepositoryGorm implementa as interfaces segregadas
var _ interfaces.PermissionReader = (*PermissionRepositoryGorm)(nil)
var _ interfaces.PermissionWriter = (*PermissionRepositoryGorm)(nil)

func (r *PermissionRepositoryGorm) FindByID(id uint) (*domain.Permission, error) <span class="cov0" title="0">{
        var permModel models.PermissionModel
        if err := r.DB.First(&amp;permModel, id).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">perm := r.mapper.ToDomain(permModel)
        return &amp;perm, nil</span>
}

func (r *PermissionRepositoryGorm) FindByName(name string) (*domain.Permission, error) <span class="cov0" title="0">{
        var permissionModel models.PermissionModel
        if err := r.DB.Where("name = ?", name).First(&amp;permissionModel).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">permission := r.mapper.ToDomain(permissionModel)
        return &amp;permission, nil</span>
}

func (r *PermissionRepositoryGorm) Create(permission *domain.Permission) error <span class="cov0" title="0">{
        permissionModel := r.mapper.ToModel(*permission)
        return r.DB.Create(&amp;permissionModel).Error
}</span>

func (r *PermissionRepositoryGorm) ListAll() ([]domain.Permission, error) <span class="cov0" title="0">{
        var permModels []models.PermissionModel
        if err := r.DB.Find(&amp;permModels).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return r.mapper.ToDomainSlice(permModels), nil</span>
}

func (r *PermissionRepositoryGorm) DeleteByName(name string) error <span class="cov0" title="0">{
        return r.DB.Where("name = ?", name).Delete(&amp;models.PermissionModel{}).Error
}</span>

func (r *PermissionRepositoryGorm) Update(permission *domain.Permission) error <span class="cov0" title="0">{
        permissionModel := r.mapper.ToModel(*permission)
        return r.DB.Save(&amp;permissionModel).Error
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package gorm

import (
        "github.com/edalferes/monogo/internal/modules/auth/adapters/repository/mappers"
        "github.com/edalferes/monogo/internal/modules/auth/adapters/repository/models"
        "github.com/edalferes/monogo/internal/modules/auth/domain"
        "github.com/edalferes/monogo/internal/modules/auth/usecase/interfaces"
        gormpkg "gorm.io/gorm"
)

type RoleRepositoryGorm struct {
        DB     *gormpkg.DB
        mapper mappers.RoleMapper
}

func NewRoleRepositoryGorm(db *gormpkg.DB) *RoleRepositoryGorm <span class="cov0" title="0">{
        return &amp;RoleRepositoryGorm{
                DB:     db,
                mapper: mappers.RoleMapper{},
        }
}</span>

// Garantir que RoleRepositoryGorm implementa as interfaces segregadas
var _ interfaces.RoleReader = (*RoleRepositoryGorm)(nil)
var _ interfaces.RoleWriter = (*RoleRepositoryGorm)(nil)

func (r *RoleRepositoryGorm) FindByID(id uint) (*domain.Role, error) <span class="cov0" title="0">{
        var roleModel models.RoleModel
        if err := r.DB.Preload("Permissions").First(&amp;roleModel, id).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">role := r.mapper.ToDomain(roleModel)
        return &amp;role, nil</span>
}

func (r *RoleRepositoryGorm) FindByName(name string) (*domain.Role, error) <span class="cov0" title="0">{
        var roleModel models.RoleModel
        if err := r.DB.Where("name = ?", name).First(&amp;roleModel).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">role := r.mapper.ToDomain(roleModel)
        return &amp;role, nil</span>
}

func (r *RoleRepositoryGorm) Create(role *domain.Role) error <span class="cov0" title="0">{
        roleModel := r.mapper.ToModel(*role)
        return r.DB.Create(&amp;roleModel).Error
}</span>

func (r *RoleRepositoryGorm) ListAll() ([]domain.Role, error) <span class="cov0" title="0">{
        var roleModels []models.RoleModel
        if err := r.DB.Preload("Permissions").Find(&amp;roleModels).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return r.mapper.ToDomainSlice(roleModels), nil</span>
}

func (r *RoleRepositoryGorm) DeleteByName(name string) error <span class="cov0" title="0">{
        return r.DB.Where("name = ?", name).Delete(&amp;models.RoleModel{}).Error
}</span>

func (r *RoleRepositoryGorm) Update(role *domain.Role) error <span class="cov0" title="0">{
        roleModel := r.mapper.ToModel(*role)
        return r.DB.Save(&amp;roleModel).Error
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package gorm

import (
        "github.com/edalferes/monogo/internal/modules/auth/adapters/repository/mappers"
        "github.com/edalferes/monogo/internal/modules/auth/adapters/repository/models"
        "github.com/edalferes/monogo/internal/modules/auth/domain"
        "github.com/edalferes/monogo/internal/modules/auth/usecase/interfaces"
        gormpkg "gorm.io/gorm"
)

type UserRepositoryGorm struct {
        DB     *gormpkg.DB
        mapper mappers.UserMapper
}

func (r *UserRepositoryGorm) FindByID(id uint) (*domain.User, error) <span class="cov0" title="0">{
        var userModel models.UserModel
        if err := r.DB.Preload("Roles.Permissions").Preload("Roles").First(&amp;userModel, id).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">user := r.mapper.ToDomain(userModel)
        return &amp;user, nil</span>
}

func (r *UserRepositoryGorm) Update(user *domain.User) error <span class="cov0" title="0">{
        userModel := r.mapper.ToModel(*user)
        return r.DB.Session(&amp;gormpkg.Session{FullSaveAssociations: true}).Updates(&amp;userModel).Error
}</span>

func (r *UserRepositoryGorm) Delete(id uint) error <span class="cov0" title="0">{
        return r.DB.Delete(&amp;models.UserModel{}, id).Error
}</span>

func NewUserRepositoryGorm(db *gormpkg.DB) *UserRepositoryGorm <span class="cov0" title="0">{
        return &amp;UserRepositoryGorm{
                DB:     db,
                mapper: mappers.UserMapper{},
        }
}</span>

// Garantir que UserRepositoryGorm implementa as interfaces segregadas
var _ interfaces.UserReader = (*UserRepositoryGorm)(nil)
var _ interfaces.UserWriter = (*UserRepositoryGorm)(nil)

func (r *UserRepositoryGorm) FindByUsername(username string) (*domain.User, error) <span class="cov0" title="0">{
        var userModel models.UserModel
        if err := r.DB.Preload("Roles.Permissions").Preload("Roles").Where("username = ?", username).First(&amp;userModel).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">user := r.mapper.ToDomain(userModel)
        return &amp;user, nil</span>
}

func (r *UserRepositoryGorm) Create(user *domain.User) error <span class="cov0" title="0">{
        userModel := r.mapper.ToModel(*user)
        return r.DB.Create(&amp;userModel).Error
}</span>

func (r *UserRepositoryGorm) ListAll() ([]domain.User, error) <span class="cov0" title="0">{
        var userModels []models.UserModel
        if err := r.DB.Preload("Roles.Permissions").Preload("Roles").Find(&amp;userModels).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return r.mapper.ToDomainSlice(userModels), nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package mappers

import (
        "github.com/edalferes/monogo/internal/modules/auth/adapters/repository/models"
        "github.com/edalferes/monogo/internal/modules/auth/domain"
)

// AuditLogMapper converte entre domain.AuditLog e models.AuditLogModel
type AuditLogMapper struct{}

// ToModel converte domain.AuditLog para models.AuditLogModel
func (m AuditLogMapper) ToModel(auditLog domain.AuditLog) models.AuditLogModel <span class="cov0" title="0">{
        return models.AuditLogModel{
                ID:        auditLog.ID,
                UserID:    auditLog.UserID,
                Username:  auditLog.Username,
                Action:    auditLog.Action,
                Status:    auditLog.Status,
                IP:        auditLog.IP,
                Details:   auditLog.Details,
                CreatedAt: auditLog.CreatedAt,
        }
}</span>

// ToDomain converte models.AuditLogModel para domain.AuditLog
func (m AuditLogMapper) ToDomain(auditLogModel models.AuditLogModel) domain.AuditLog <span class="cov0" title="0">{
        return domain.AuditLog{
                ID:        auditLogModel.ID,
                UserID:    auditLogModel.UserID,
                Username:  auditLogModel.Username,
                Action:    auditLogModel.Action,
                Status:    auditLogModel.Status,
                IP:        auditLogModel.IP,
                Details:   auditLogModel.Details,
                CreatedAt: auditLogModel.CreatedAt,
        }
}</span>

// ToModelSlice converte []domain.AuditLog para []models.AuditLogModel
func (m AuditLogMapper) ToModelSlice(auditLogs []domain.AuditLog) []models.AuditLogModel <span class="cov0" title="0">{
        auditLogModels := make([]models.AuditLogModel, len(auditLogs))
        for i, auditLog := range auditLogs </span><span class="cov0" title="0">{
                auditLogModels[i] = m.ToModel(auditLog)
        }</span>
        <span class="cov0" title="0">return auditLogModels</span>
}

// ToDomainSlice converte []models.AuditLogModel para []domain.AuditLog
func (m AuditLogMapper) ToDomainSlice(auditLogModels []models.AuditLogModel) []domain.AuditLog <span class="cov0" title="0">{
        auditLogs := make([]domain.AuditLog, len(auditLogModels))
        for i, auditLogModel := range auditLogModels </span><span class="cov0" title="0">{
                auditLogs[i] = m.ToDomain(auditLogModel)
        }</span>
        <span class="cov0" title="0">return auditLogs</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package mappers

import (
        "github.com/edalferes/monogo/internal/modules/auth/adapters/repository/models"
        "github.com/edalferes/monogo/internal/modules/auth/domain"
)

// PermissionMapper converte entre domain.Permission e models.PermissionModel
type PermissionMapper struct{}

// ToModel converte domain.Permission para models.PermissionModel
func (m PermissionMapper) ToModel(permission domain.Permission) models.PermissionModel <span class="cov0" title="0">{
        return models.PermissionModel{
                ID:   permission.ID,
                Name: permission.Name,
        }
}</span>

// ToDomain converte models.PermissionModel para domain.Permission
func (m PermissionMapper) ToDomain(permissionModel models.PermissionModel) domain.Permission <span class="cov0" title="0">{
        return domain.Permission{
                ID:   permissionModel.ID,
                Name: permissionModel.Name,
        }
}</span>

// ToModelSlice converte []domain.Permission para []models.PermissionModel
func (m PermissionMapper) ToModelSlice(permissions []domain.Permission) []models.PermissionModel <span class="cov0" title="0">{
        permissionModels := make([]models.PermissionModel, len(permissions))
        for i, permission := range permissions </span><span class="cov0" title="0">{
                permissionModels[i] = m.ToModel(permission)
        }</span>
        <span class="cov0" title="0">return permissionModels</span>
}

// ToDomainSlice converte []models.PermissionModel para []domain.Permission
func (m PermissionMapper) ToDomainSlice(permissionModels []models.PermissionModel) []domain.Permission <span class="cov0" title="0">{
        permissions := make([]domain.Permission, len(permissionModels))
        for i, permissionModel := range permissionModels </span><span class="cov0" title="0">{
                permissions[i] = m.ToDomain(permissionModel)
        }</span>
        <span class="cov0" title="0">return permissions</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package mappers

import (
        "github.com/edalferes/monogo/internal/modules/auth/adapters/repository/models"
        "github.com/edalferes/monogo/internal/modules/auth/domain"
)

// RoleMapper converte entre domain.Role e models.RoleModel
type RoleMapper struct{}

// ToModel converte domain.Role para models.RoleModel
func (m RoleMapper) ToModel(role domain.Role) models.RoleModel <span class="cov0" title="0">{
        permissionModels := make([]models.PermissionModel, len(role.Permissions))
        for i, permission := range role.Permissions </span><span class="cov0" title="0">{
                permissionModels[i] = PermissionMapper{}.ToModel(permission)
        }</span>

        <span class="cov0" title="0">return models.RoleModel{
                ID:          role.ID,
                Name:        role.Name,
                Permissions: permissionModels,
        }</span>
}

// ToDomain converte models.RoleModel para domain.Role
func (m RoleMapper) ToDomain(roleModel models.RoleModel) domain.Role <span class="cov0" title="0">{
        permissions := make([]domain.Permission, len(roleModel.Permissions))
        for i, permissionModel := range roleModel.Permissions </span><span class="cov0" title="0">{
                permissions[i] = PermissionMapper{}.ToDomain(permissionModel)
        }</span>

        <span class="cov0" title="0">return domain.Role{
                ID:          roleModel.ID,
                Name:        roleModel.Name,
                Permissions: permissions,
        }</span>
}

// ToModelSlice converte []domain.Role para []models.RoleModel
func (m RoleMapper) ToModelSlice(roles []domain.Role) []models.RoleModel <span class="cov0" title="0">{
        roleModels := make([]models.RoleModel, len(roles))
        for i, role := range roles </span><span class="cov0" title="0">{
                roleModels[i] = m.ToModel(role)
        }</span>
        <span class="cov0" title="0">return roleModels</span>
}

// ToDomainSlice converte []models.RoleModel para []domain.Role
func (m RoleMapper) ToDomainSlice(roleModels []models.RoleModel) []domain.Role <span class="cov0" title="0">{
        roles := make([]domain.Role, len(roleModels))
        for i, roleModel := range roleModels </span><span class="cov0" title="0">{
                roles[i] = m.ToDomain(roleModel)
        }</span>
        <span class="cov0" title="0">return roles</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package mappers

import (
        "github.com/edalferes/monogo/internal/modules/auth/adapters/repository/models"
        "github.com/edalferes/monogo/internal/modules/auth/domain"
)

// UserMapper converte entre domain.User e models.UserModel
type UserMapper struct{}

// ToModel converte domain.User para models.UserModel
func (m UserMapper) ToModel(user domain.User) models.UserModel <span class="cov0" title="0">{
        roleModels := make([]models.RoleModel, len(user.Roles))
        for i, role := range user.Roles </span><span class="cov0" title="0">{
                roleModels[i] = RoleMapper{}.ToModel(role)
        }</span>

        <span class="cov0" title="0">return models.UserModel{
                ID:       user.ID,
                Username: user.Username,
                Password: user.Password,
                Roles:    roleModels,
        }</span>
}

// ToDomain converte models.UserModel para domain.User
func (m UserMapper) ToDomain(userModel models.UserModel) domain.User <span class="cov0" title="0">{
        roles := make([]domain.Role, len(userModel.Roles))
        for i, roleModel := range userModel.Roles </span><span class="cov0" title="0">{
                roles[i] = RoleMapper{}.ToDomain(roleModel)
        }</span>

        <span class="cov0" title="0">return domain.User{
                ID:       userModel.ID,
                Username: userModel.Username,
                Password: userModel.Password,
                Roles:    roles,
        }</span>
}

// ToModelSlice converte []domain.User para []models.UserModel
func (m UserMapper) ToModelSlice(users []domain.User) []models.UserModel <span class="cov0" title="0">{
        userModels := make([]models.UserModel, len(users))
        for i, user := range users </span><span class="cov0" title="0">{
                userModels[i] = m.ToModel(user)
        }</span>
        <span class="cov0" title="0">return userModels</span>
}

// ToDomainSlice converte []models.UserModel para []domain.User
func (m UserMapper) ToDomainSlice(userModels []models.UserModel) []domain.User <span class="cov0" title="0">{
        users := make([]domain.User, len(userModels))
        for i, userModel := range userModels </span><span class="cov0" title="0">{
                users[i] = m.ToDomain(userModel)
        }</span>
        <span class="cov0" title="0">return users</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package models

import "time"

// AuditLogModel representa a estrutura de dados para GORM
type AuditLogModel struct {
        ID        uint      `gorm:"primaryKey"`
        UserID    *uint     `gorm:"index"`
        Username  string    `gorm:"not null"`
        Action    string    `gorm:"not null"`
        Status    string    `gorm:"not null"`
        IP        string    `gorm:"not null"`
        Details   string    `gorm:"type:text"`
        CreatedAt time.Time `gorm:"autoCreateTime"`
}

func (AuditLogModel) TableName() string <span class="cov0" title="0">{
        return "audit_logs"
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package models

// PermissionModel representa a estrutura de dados para GORM
type PermissionModel struct {
        ID   uint   `gorm:"primaryKey"`
        Name string `gorm:"unique;not null"`
}

func (PermissionModel) TableName() string <span class="cov0" title="0">{
        return "permissions"
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package models

// RoleModel representa a estrutura de dados para GORM
type RoleModel struct {
        ID          uint              `gorm:"primaryKey"`
        Name        string            `gorm:"unique;not null"`
        Permissions []PermissionModel `gorm:"many2many:role_permissions;"`
}

func (RoleModel) TableName() string <span class="cov0" title="0">{
        return "roles"
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package models

// UserModel representa a estrutura de dados para GORM
type UserModel struct {
        ID       uint        `gorm:"primaryKey"`
        Username string      `gorm:"unique;not null"`
        Password string      `gorm:"not null"`
        Roles    []RoleModel `gorm:"many2many:user_roles;"`
}

func (UserModel) TableName() string <span class="cov0" title="0">{
        return "users"
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package auth

import "github.com/edalferes/monogo/internal/modules/auth/adapters/repository/models"

func Entities() []interface{} <span class="cov0" title="0">{
        return []interface{}{
                &amp;models.UserModel{},
                &amp;models.RoleModel{},
                &amp;models.PermissionModel{},
                &amp;models.AuditLogModel{},
        }
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package auth

import (
        authmiddleware "github.com/edalferes/monogo/internal/modules/auth/adapters/http"
        "github.com/labstack/echo/v4"
)

// JWTMiddleware exposes the JWT middleware for use by other modules
func JWTMiddleware(secret string) echo.MiddlewareFunc <span class="cov0" title="0">{
        return authmiddleware.JWTMiddleware(secret)
}</span>

// RequireRoles exposes the role-based middleware for use by other modules
func RequireRoles(roles ...string) echo.MiddlewareFunc <span class="cov0" title="0">{
        return authmiddleware.RequireRoles(roles...)
}</span>

// RequirePermissions exposes the permission-based middleware for use by other modules
func RequirePermissions(perms ...string) echo.MiddlewareFunc <span class="cov0" title="0">{
        return authmiddleware.RequirePermissions(perms...)
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package auth

import (
        "time"

        handler_admin "github.com/edalferes/monogo/internal/modules/auth/adapters/http/handlers/admin"
        "github.com/edalferes/monogo/internal/modules/auth/adapters/http/handlers/login"
        gormrepo "github.com/edalferes/monogo/internal/modules/auth/adapters/repository/gorm"
        "github.com/edalferes/monogo/internal/modules/auth/service"
        permUC "github.com/edalferes/monogo/internal/modules/auth/usecase/permission"
        roleUC "github.com/edalferes/monogo/internal/modules/auth/usecase/role"
        userUC "github.com/edalferes/monogo/internal/modules/auth/usecase/user"
        "github.com/edalferes/monogo/pkg/logger"
        "github.com/labstack/echo/v4"
        "gorm.io/gorm"
)

func WireUp(group *echo.Group, db *gorm.DB, jwtSecret string, log logger.Logger) <span class="cov0" title="0">{

        userRepo := gormrepo.NewUserRepositoryGorm(db)
        roleRepo := gormrepo.NewRoleRepositoryGorm(db)
        permRepo := gormrepo.NewPermissionRepositoryGorm(db)
        passwordService := service.NewPasswordService()
        jwtService := service.NewJWTService(jwtSecret, time.Hour) // 1 hour expiration token
        auditLogRepo := gormrepo.NewAuditLogRepositoryGorm(db)
        auditService := service.NewAuditService(auditLogRepo)

        // Handler public (only login)
        publicHandler := &amp;login.Handler{
                LoginUseCase: &amp;userUC.LoginWithAuditUseCase{
                        UserRepo:        userRepo,
                        PasswordService: passwordService,
                        JWTService:      jwtService,
                        AuditService:    auditService,
                },
                Logger: log,
        }
        group.POST("/auth/login", publicHandler.Login)

        // User use cases
        listUsersUC := &amp;userUC.ListUsersUseCase{UserRepo: userRepo}
        createUserUC := &amp;userUC.RegisterUseCase{
                UserReader:      userRepo,
                UserWriter:      userRepo,
                RoleReader:      roleRepo,
                PasswordService: passwordService,
        }
        // Use cases para role
        listRolesUC := &amp;roleUC.ListRolesUseCase{RoleRepo: roleRepo}
        createRoleUC := &amp;roleUC.CreateRoleUseCase{RoleRepo: roleRepo}
        deleteRoleUC := &amp;roleUC.DeleteRoleUseCase{RoleRepo: roleRepo}
        // Use cases para permission
        listPermissionsUC := &amp;permUC.ListPermissionsUseCase{PermissionRepo: permRepo}
        createPermissionUC := &amp;permUC.CreatePermissionUseCase{PermissionRepo: permRepo}
        deletePermissionUC := &amp;permUC.DeletePermissionUseCase{PermissionRepo: permRepo}

        adminUserHandler := &amp;handler_admin.AdminUserHandler{
                ListUsersUC:  listUsersUC,
                CreateUserUC: createUserUC,
                // Add other use cases as needed
        }
        adminRolePermHandler := &amp;handler_admin.AdminHandler{
                ListRolesUC:        listRolesUC,
                CreateRoleUC:       createRoleUC,
                DeleteRoleUC:       deleteRoleUC,
                ListPermissionsUC:  listPermissionsUC,
                CreatePermissionUC: createPermissionUC,
                DeletePermissionUC: deletePermissionUC,
        }
        adminGroup := group.Group("/admin")
        adminGroup.Use(JWTMiddleware(jwtSecret))
        adminGroup.POST("/users", adminUserHandler.CreateUser)
        adminGroup.GET("/users", adminUserHandler.ListUsers)
        // Roles
        adminGroup.GET("/roles", adminRolePermHandler.ListRoles)
        adminGroup.POST("/roles", adminRolePermHandler.CreateRole)
        adminGroup.DELETE("/roles/:name", adminRolePermHandler.DeleteRole)
        // Permissions
        adminGroup.GET("/permissions", adminRolePermHandler.ListPermissions)
        adminGroup.POST("/permissions", adminRolePermHandler.CreatePermission)
        adminGroup.DELETE("/permissions/:name", adminRolePermHandler.DeletePermission)
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package auth

import (
        gormrepo "github.com/edalferes/monogo/internal/modules/auth/adapters/repository/gorm"
        "github.com/edalferes/monogo/internal/modules/auth/domain"
        "github.com/edalferes/monogo/internal/modules/auth/service"
        "gorm.io/gorm"
)

const (
        RootUsername string = "root"
        RootPassword string = "ZDcxMDUxZmM4M2Jl"
)

func Seed(db *gorm.DB) error <span class="cov0" title="0">{
        roleRepo := gormrepo.NewRoleRepositoryGorm(db)
        permRepo := gormrepo.NewPermissionRepositoryGorm(db)
        userRepo := gormrepo.NewUserRepositoryGorm(db)
        passwordService := service.NewPasswordService()

        defaultRoles := []string{"admin", "user"}
        defaultPerms := []string{"read", "write", "delete"}

        // Seed permissions
        for _, permName := range defaultPerms </span><span class="cov0" title="0">{
                _, err := permRepo.FindByName(permName)
                if err != nil </span><span class="cov0" title="0">{
                        if err := permRepo.Create(&amp;domain.Permission{Name: permName}); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        // Seed roles and assign permissions
        <span class="cov0" title="0">allPerms, err := permRepo.ListAll()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for _, roleName := range defaultRoles </span><span class="cov0" title="0">{
                var permsToAssign []domain.Permission
                if roleName == "admin" </span><span class="cov0" title="0">{
                        permsToAssign = allPerms // admin allows all permissions
                }</span> else<span class="cov0" title="0"> {
                        // user only read
                        for _, p := range allPerms </span><span class="cov0" title="0">{
                                if p.Name == "read" </span><span class="cov0" title="0">{
                                        permsToAssign = append(permsToAssign, p)
                                }</span>
                        }
                }

                // Check if role already exists
                <span class="cov0" title="0">_, err := roleRepo.FindByName(roleName)
                if err != nil </span><span class="cov0" title="0">{
                        // Role doesn't exist, create it
                        role := &amp;domain.Role{Name: roleName, Permissions: permsToAssign}
                        if err := roleRepo.Create(role); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                // Note: For simplicity, we're not updating existing roles permissions
                // In a real app, you might want to implement an Update method for this
        }

        // Seed root user
        <span class="cov0" title="0">rootUsername := RootUsername
        rootPassword := RootPassword
        _, err = userRepo.FindByUsername(rootUsername)
        if err != nil </span><span class="cov0" title="0">{
                adminRole, err := roleRepo.FindByName("admin")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">userRole, err := roleRepo.FindByName("user")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">hash, err := passwordService.Hash(rootPassword)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">rootUser := &amp;domain.User{
                        Username: rootUsername,
                        Password: hash,
                        Roles:    []domain.Role{*adminRole, *userRole},
                }
                if err := userRepo.Create(rootUser); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package service

import (
        "github.com/edalferes/monogo/internal/modules/auth/domain"
        "github.com/edalferes/monogo/internal/modules/auth/usecase/interfaces"
)

type AuditService interface {
        Log(userID *uint, username, action, status, ip, details string) error
}

type auditService struct {
        repo interfaces.AuditLogRepository
}

func NewAuditService(repo interfaces.AuditLogRepository) AuditService <span class="cov0" title="0">{
        return &amp;auditService{repo: repo}
}</span>

func (s *auditService) Log(userID *uint, username, action, status, ip, details string) error <span class="cov0" title="0">{
        log := &amp;domain.AuditLog{
                UserID:   userID,
                Username: username,
                Action:   action,
                Status:   status,
                IP:       ip,
                Details:  details,
        }
        return s.repo.Create(log)
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package service

import (
        "time"

        "github.com/golang-jwt/jwt/v5"
)

type JWTService interface {
        GenerateToken(userID uint, username string, roles []string) (string, error)
        ValidateToken(token string) (*jwt.Token, error)
}

type jwtService struct {
        secretKey string
        expiry    time.Duration
}

func NewJWTService(secretKey string, expiry time.Duration) JWTService <span class="cov0" title="0">{
        return &amp;jwtService{secretKey, expiry}
}</span>

func (j *jwtService) GenerateToken(userID uint, username string, roles []string) (string, error) <span class="cov0" title="0">{
        claims := jwt.MapClaims{
                "uid":      userID,
                "username": username,
                "roles":    roles,
                "exp":      time.Now().Add(j.expiry).Unix(),
        }
        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        return token.SignedString([]byte(j.secretKey))
}</span>

func (j *jwtService) ValidateToken(tokenString string) (*jwt.Token, error) <span class="cov0" title="0">{
        return jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                return []byte(j.secretKey), nil
        }</span>)
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package service

import "golang.org/x/crypto/bcrypt"

type PasswordService interface {
        Hash(password string) (string, error)
        Compare(hash, password string) error
}

type passwordService struct{}

func NewPasswordService() PasswordService <span class="cov0" title="0">{
        return &amp;passwordService{}
}</span>

func (p *passwordService) Hash(password string) (string, error) <span class="cov0" title="0">{
        bytes, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
        return string(bytes), err
}</span>

func (p *passwordService) Compare(hash, password string) error <span class="cov0" title="0">{
        return bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">package permission

type CheckPermissionUseCase struct {
        // TODO: added dependencies like UserRepository, PermissionRepository
}

func (u *CheckPermissionUseCase) Execute(userID uint, permissionName string) (bool, error) <span class="cov0" title="0">{
        // TODO: implement permission check
        return false, nil
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">package permission

import (
        "github.com/edalferes/monogo/internal/modules/auth/domain"
        "github.com/edalferes/monogo/internal/modules/auth/usecase/interfaces"
)

type CreatePermissionUseCase struct {
        PermissionRepo interfaces.PermissionWriter
}

func (u *CreatePermissionUseCase) Execute(name string) error <span class="cov0" title="0">{
        perm := &amp;domain.Permission{Name: name}
        return u.PermissionRepo.Create(perm)
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">package permission

import "github.com/edalferes/monogo/internal/modules/auth/usecase/interfaces"

type DeletePermissionUseCase struct {
        PermissionRepo interfaces.PermissionWriter
}

func (u *DeletePermissionUseCase) Execute(name string) error <span class="cov0" title="0">{
        return u.PermissionRepo.DeleteByName(name)
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">package permission

import (
        "github.com/edalferes/monogo/internal/modules/auth/domain"
        "github.com/edalferes/monogo/internal/modules/auth/usecase/interfaces"
)

type GetPermissionByIDUseCase struct {
        PermissionRepo interfaces.PermissionReader
}

// Supondo que PermissionRepository tenha FindByID
func (u *GetPermissionByIDUseCase) Execute(id uint) (*domain.Permission, error) <span class="cov0" title="0">{
        return u.PermissionRepo.FindByID(id)
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">package permission

import (
        "github.com/edalferes/monogo/internal/modules/auth/domain"
        "github.com/edalferes/monogo/internal/modules/auth/usecase/interfaces"
)

type ListPermissionsUseCase struct {
        PermissionRepo interfaces.PermissionReader
}

func (u *ListPermissionsUseCase) Execute() ([]domain.Permission, error) <span class="cov0" title="0">{
        return u.PermissionRepo.ListAll()
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">package permission

import (
        "github.com/edalferes/monogo/internal/modules/auth/usecase/interfaces"
)

type UpdatePermissionInput struct {
        ID   uint
        Name string
}

type UpdatePermissionUseCase struct {
        PermissionReader interfaces.PermissionReader
        PermissionWriter interfaces.PermissionWriter
}

func (u *UpdatePermissionUseCase) Execute(input UpdatePermissionInput) error <span class="cov0" title="0">{
        perm, err := u.PermissionReader.FindByID(input.ID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if input.Name != "" </span><span class="cov0" title="0">{
                perm.Name = input.Name
        }</span>
        <span class="cov0" title="0">return u.PermissionWriter.Update(perm)</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package role

import (
        "github.com/edalferes/monogo/internal/modules/auth/domain"
        "github.com/edalferes/monogo/internal/modules/auth/usecase/interfaces"
)

type CreateRoleUseCase struct {
        RoleRepo interfaces.RoleWriter
}

func (u *CreateRoleUseCase) Execute(name string, permissionIDs []uint) error <span class="cov0" title="0">{
        var perms []domain.Permission
        for _, pid := range permissionIDs </span><span class="cov0" title="0">{
                perms = append(perms, domain.Permission{ID: pid})
        }</span>
        <span class="cov0" title="0">role := &amp;domain.Role{Name: name, Permissions: perms}
        return u.RoleRepo.Create(role)</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package role

import "github.com/edalferes/monogo/internal/modules/auth/usecase/interfaces"

type DeleteRoleUseCase struct {
        RoleRepo interfaces.RoleWriter
}

func (u *DeleteRoleUseCase) Execute(name string) error <span class="cov0" title="0">{
        return u.RoleRepo.DeleteByName(name)
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">package role

import (
        "github.com/edalferes/monogo/internal/modules/auth/domain"
        "github.com/edalferes/monogo/internal/modules/auth/usecase/interfaces"
)

type GetRoleByIDUseCase struct {
        RoleRepo interfaces.RoleReader
}

func (u *GetRoleByIDUseCase) Execute(id uint) (*domain.Role, error) <span class="cov0" title="0">{
        return u.RoleRepo.FindByID(id)
}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">package role

import (
        "github.com/edalferes/monogo/internal/modules/auth/domain"
        "github.com/edalferes/monogo/internal/modules/auth/usecase/interfaces"
)

type ListRolesUseCase struct {
        RoleRepo interfaces.RoleReader
}

func (u *ListRolesUseCase) Execute() ([]domain.Role, error) <span class="cov0" title="0">{
        return u.RoleRepo.ListAll()
}</span>
</pre>
		
		<pre class="file" id="file42" style="display: none">package role

import (
        "github.com/edalferes/monogo/internal/modules/auth/domain"
        "github.com/edalferes/monogo/internal/modules/auth/usecase/interfaces"
)

type UpdateRoleInput struct {
        ID            uint
        Name          string
        PermissionIDs []uint
}

type UpdateRoleUseCase struct {
        RoleReader interfaces.RoleReader
        RoleWriter interfaces.RoleWriter
}

func (u *UpdateRoleUseCase) Execute(input UpdateRoleInput) error <span class="cov0" title="0">{
        role, err := u.RoleReader.FindByID(input.ID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if input.Name != "" </span><span class="cov0" title="0">{
                role.Name = input.Name
        }</span>
        <span class="cov0" title="0">if input.PermissionIDs != nil </span><span class="cov0" title="0">{
                var perms []domain.Permission
                for _, pid := range input.PermissionIDs </span><span class="cov0" title="0">{
                        perms = append(perms, domain.Permission{ID: pid})
                }</span>
                <span class="cov0" title="0">role.Permissions = perms</span>
        }
        <span class="cov0" title="0">return u.RoleWriter.Update(role)</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package user

type AssignRoleUseCase struct {
        // TODO: added dependencies like UserRepository, RoleRepository
}

func (u *AssignRoleUseCase) Execute(userID uint, roleName string) error <span class="cov0" title="0">{
        // TODO: implement role assignment
        return nil
}</span>
</pre>
		
		<pre class="file" id="file44" style="display: none">package user

import "github.com/edalferes/monogo/internal/modules/auth/usecase/interfaces"

type DeleteUserUseCase struct {
        UserRepo interfaces.UserWriter
}

func (u *DeleteUserUseCase) Execute(id uint) error <span class="cov0" title="0">{
        return u.UserRepo.Delete(id)
}</span>
</pre>
		
		<pre class="file" id="file45" style="display: none">package user

import (
        "github.com/edalferes/monogo/internal/modules/auth/domain"
        "github.com/edalferes/monogo/internal/modules/auth/usecase/interfaces"
)

type GetUserByIDUseCase struct {
        UserRepo interfaces.UserReader
}

func (u *GetUserByIDUseCase) Execute(id uint) (*domain.User, error) <span class="cov0" title="0">{
        return u.UserRepo.FindByID(id)
}</span>
</pre>
		
		<pre class="file" id="file46" style="display: none">package user

import (
        "github.com/edalferes/monogo/internal/modules/auth/domain"
        "github.com/edalferes/monogo/internal/modules/auth/usecase/interfaces"
)

type ListUsersUseCase struct {
        UserRepo interfaces.UserReader
}

func (u *ListUsersUseCase) Execute() ([]domain.User, error) <span class="cov0" title="0">{
        return u.UserRepo.ListAll()
}</span>
</pre>
		
		<pre class="file" id="file47" style="display: none">package user

import (
        "github.com/edalferes/monogo/internal/modules/auth/errors"
        "github.com/edalferes/monogo/internal/modules/auth/service"
        "github.com/edalferes/monogo/internal/modules/auth/usecase/interfaces"
)

type LoginUseCase struct {
        UserRepo        interfaces.UserReader
        PasswordService service.PasswordService
        JWTService      service.JWTService
}

func (u *LoginUseCase) Execute(username, password string) (string, error) <span class="cov0" title="0">{
        user, err := u.UserRepo.FindByUsername(username)
        if err != nil || user == nil </span><span class="cov0" title="0">{
                return "", errors.ErrInvalidCredentials
        }</span>
        <span class="cov0" title="0">if err := u.PasswordService.Compare(user.Password, password); err != nil </span><span class="cov0" title="0">{
                return "", errors.ErrInvalidCredentials
        }</span>
        // Extract role names from user roles
        <span class="cov0" title="0">roles := make([]string, len(user.Roles))
        for i, r := range user.Roles </span><span class="cov0" title="0">{
                roles[i] = r.Name
        }</span>
        <span class="cov0" title="0">token, err := u.JWTService.GenerateToken(user.ID, user.Username, roles)
        if err != nil </span><span class="cov0" title="0">{
                return "", errors.ErrInvalidData
        }</span>
        <span class="cov0" title="0">return token, nil</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">// Package user contains use cases related to user operations such as authentication,
// registration, and profile management.
package user

import (
        "github.com/edalferes/monogo/internal/modules/auth/errors"
        "github.com/edalferes/monogo/internal/modules/auth/service"
        "github.com/edalferes/monogo/internal/modules/auth/usecase/interfaces"
)

// LoginWithAuditUseCase handles user authentication with comprehensive audit logging.
//
// This use case implements secure user login functionality that:
//   - Validates user credentials against the database
//   - Uses bcrypt for secure password comparison
//   - Generates JWT tokens for successful authentication
//   - Logs all authentication attempts for security monitoring
//   - Returns appropriate errors for different failure scenarios
//
// Security features:
//   - Password comparison using constant-time bcrypt
//   - Audit logging for both successful and failed attempts
//   - Generic error messages to prevent username enumeration
//   - IP address tracking for suspicious activity detection
//
// Dependencies:
//   - UserRepo: for user data retrieval (read-only operations)
//   - PasswordService: for secure password comparison
//   - JWTService: for token generation
//   - AuditService: for security event logging
//
// Example usage:
//
//        loginUC := &amp;LoginWithAuditUseCase{
//                UserRepo:        userRepo,
//                PasswordService: passwordSvc,
//                JWTService:      jwtSvc,
//                AuditService:    auditSvc,
//        }
//
//        token, err := loginUC.Execute("admin", "password123", "192.168.1.100")
//        if err != nil {
//                // Handle authentication failure
//                return err
//        }
//        // Use token for subsequent requests
type LoginWithAuditUseCase struct {
        UserRepo        interfaces.UserReader   // Repository for user data access
        PasswordService service.PasswordService // Service for password operations
        JWTService      service.JWTService      // Service for JWT token management
        AuditService    service.AuditService    // Service for audit logging
}

// Execute performs user authentication with comprehensive audit logging.
//
// This method handles the complete authentication flow:
//  1. Looks up user by username
//  2. Compares provided password with stored hash
//  3. Generates JWT token with user roles
//  4. Logs the authentication attempt (success or failure)
//
// Parameters:
//   - username: the username provided by the client
//   - password: the plain text password provided by the client
//   - ip: the client's IP address for audit logging
//
// Returns:
//   - string: JWT token if authentication succeeds
//   - error: authentication error (see errors package for types)
//
// Possible errors:
//   - ErrInvalidCredentials: username not found or password mismatch
//   - ErrInvalidData: token generation failed
//
// Security considerations:
//   - Both "user not found" and "wrong password" return the same error to prevent username enumeration
//   - All attempts are logged with appropriate detail level
//   - IP address is captured for suspicious activity detection
//   - Failed attempts include reason in audit details for administrator review
//
// Example:
//
//        token, err := usecase.Execute("alice", "secret123", "192.168.1.100")
//        if err == errors.ErrInvalidCredentials {
//                return echo.NewHTTPError(http.StatusUnauthorized, "Invalid credentials")
//        }
//        // Return token to client
func (u *LoginWithAuditUseCase) Execute(username, password, ip string) (string, error) <span class="cov0" title="0">{
        user, err := u.UserRepo.FindByUsername(username)
        if err != nil || user == nil </span><span class="cov0" title="0">{
                u.AuditService.Log(nil, username, "login_failed", "fail", ip, "user not found or error")
                return "", errors.ErrInvalidCredentials
        }</span>
        <span class="cov0" title="0">if err := u.PasswordService.Compare(user.Password, password); err != nil </span><span class="cov0" title="0">{
                u.AuditService.Log(&amp;user.ID, username, "login_failed", "fail", ip, "wrong password")
                return "", errors.ErrInvalidCredentials
        }</span>
        <span class="cov0" title="0">roles := make([]string, len(user.Roles))
        for i, r := range user.Roles </span><span class="cov0" title="0">{
                roles[i] = r.Name
        }</span>
        <span class="cov0" title="0">token, err := u.JWTService.GenerateToken(user.ID, user.Username, roles)
        if err != nil </span><span class="cov0" title="0">{
                u.AuditService.Log(&amp;user.ID, username, "login_failed", "fail", ip, "token error")
                return "", errors.ErrInvalidData
        }</span>
        <span class="cov0" title="0">u.AuditService.Log(&amp;user.ID, username, "login_success", "ok", ip, "")
        return token, nil</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package user

import (
        "github.com/edalferes/monogo/internal/modules/auth/domain"
        "github.com/edalferes/monogo/internal/modules/auth/errors"
        "github.com/edalferes/monogo/internal/modules/auth/service"
        "github.com/edalferes/monogo/internal/modules/auth/usecase/interfaces"
)

type RegisterUseCase struct {
        UserReader      interfaces.UserReader
        UserWriter      interfaces.UserWriter
        RoleReader      interfaces.RoleReader
        PasswordService service.PasswordService
}

func (u *RegisterUseCase) Execute(username, password string) error <span class="cov0" title="0">{
        if user, _ := u.UserReader.FindByUsername(username); user != nil </span><span class="cov0" title="0">{
                return errors.ErrUserAlreadyExists
        }</span>
        <span class="cov0" title="0">hash, err := u.PasswordService.Hash(password)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">role, err := u.RoleReader.FindByName("user")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">user := &amp;domain.User{
                Username: username,
                Password: hash,
                Roles:    []domain.Role{*role},
        }
        return u.UserWriter.Create(user)</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package user

import (
        "github.com/edalferes/monogo/internal/modules/auth/domain"
        "github.com/edalferes/monogo/internal/modules/auth/usecase/interfaces"
)

type UpdateUserInput struct {
        ID       uint
        Username string
        Password *string
        RoleIDs  []uint
}

type UpdateUserUseCase struct {
        UserReader interfaces.UserReader
        UserWriter interfaces.UserWriter
        RoleReader interfaces.RoleReader
}

func (u *UpdateUserUseCase) Execute(input UpdateUserInput) error <span class="cov0" title="0">{
        user, err := u.UserReader.FindByID(input.ID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if input.Username != "" </span><span class="cov0" title="0">{
                user.Username = input.Username
        }</span>
        <span class="cov0" title="0">if input.Password != nil </span><span class="cov0" title="0">{
                user.Password = *input.Password
        }</span>
        <span class="cov0" title="0">if input.RoleIDs != nil </span><span class="cov0" title="0">{
                var roles []domain.Role
                for _, rid := range input.RoleIDs </span><span class="cov0" title="0">{
                        role, err := u.RoleReader.FindByID(rid)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">roles = append(roles, *role)</span>
                }
                <span class="cov0" title="0">user.Roles = roles</span>
        }
        <span class="cov0" title="0">return u.UserWriter.Update(user)</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package handler

import (
        "net/http"

        "github.com/labstack/echo/v4"
)

type Handler struct{}

// Test godoc
// @Summary Protected endpoint for testing roles/permissions
// @Tags testmodule
// @Security BearerAuth
// @Success 200 {object} map[string]string
// @Failure 401 {object} map[string]string
// @Failure 403 {object} map[string]string
// @Router /v1/test/protected [get]
func (h *Handler) Protected(c echo.Context) error <span class="cov0" title="0">{
        return c.JSON(http.StatusOK, map[string]string{"message": "authorized access!"})
}</span>
</pre>
		
		<pre class="file" id="file52" style="display: none">package testmodule

import (
        "github.com/edalferes/monogo/internal/modules/auth"
        "github.com/edalferes/monogo/internal/modules/testmodule/adapters/http/handler"
        "github.com/labstack/echo/v4"
)

// WireUp register the testmodule routes, protecting with JWT and role check
func WireUp(group *echo.Group, jwtSecret string) <span class="cov0" title="0">{
        h := &amp;handler.Handler{}
        protected := group.Group("/test")
        protected.Use(auth.JWTMiddleware(jwtSecret))
        protected.GET("/protected", h.Protected, auth.RequireRoles("user"))
}</span>
</pre>
		
		<pre class="file" id="file53" style="display: none">package logger

import "io"

// Config defines the logger configuration
type Config struct {
        Level      string // "debug", "info", "warn", "error", "fatal"
        Output     io.Writer
        OutputFile string // Se especificado, escreve em arquivo
        Format     string // "json", "console"
        Service    string // Service name for identification
}

// DefaultConfig returns a default configuration
func DefaultConfig() Config <span class="cov0" title="0">{
        return Config{
                Level:   "info",
                Format:  "json",
                Service: "monogo",
        }
}</span>
</pre>
		
		<pre class="file" id="file54" style="display: none">package logger

// New creates a new logger with configuration
func New(config Config) Logger <span class="cov0" title="0">{
        return NewZerologLogger(config)
}</span>

// NewDefault creates a new logger with default configuration
func NewDefault() Logger <span class="cov0" title="0">{
        return NewZerologLogger(DefaultConfig())
}</span>
</pre>
		
		<pre class="file" id="file55" style="display: none">package logger

import (
        "os"

        "github.com/rs/zerolog"
)

// ZerologLogger implements the Logger interface using zerolog
type ZerologLogger struct {
        logger zerolog.Logger
}

// NewZerologLogger creates a new logger instance with the specified configuration
func NewZerologLogger(config Config) Logger <span class="cov0" title="0">{
        var output = config.Output
        if output == nil </span><span class="cov0" title="0">{
                if config.OutputFile != "" </span><span class="cov0" title="0">{
                        file, err := os.OpenFile(config.OutputFile, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
                        if err != nil </span><span class="cov0" title="0">{
                                output = os.Stdout // fallback
                        }</span> else<span class="cov0" title="0"> {
                                output = file
                        }</span>
                } else<span class="cov0" title="0"> {
                        output = os.Stdout
                }</span>
        }

        <span class="cov0" title="0">logger := zerolog.New(output).With().Timestamp()

        // Adicionar service name se especificado
        if config.Service != "" </span><span class="cov0" title="0">{
                logger = logger.Str("service", config.Service)
        }</span>

        <span class="cov0" title="0">zeroLogger := logger.Logger()

        // Configure log level
        if config.Level != "" </span><span class="cov0" title="0">{
                if level, err := zerolog.ParseLevel(config.Level); err == nil </span><span class="cov0" title="0">{
                        zeroLogger = zeroLogger.Level(level)
                }</span>
        }

        // Configurar formato se for console
        <span class="cov0" title="0">if config.Format == "console" </span><span class="cov0" title="0">{
                output = zerolog.ConsoleWriter{Out: output}
                zeroLogger = zerolog.New(output).With().Timestamp().Logger()
        }</span>

        <span class="cov0" title="0">return &amp;ZerologLogger{logger: zeroLogger}</span>
}

// Info implements Logger.Info
func (z *ZerologLogger) Info() Event <span class="cov0" title="0">{
        return &amp;ZerologEvent{event: z.logger.Info()}
}</span>

// Error implements Logger.Error
func (z *ZerologLogger) Error() Event <span class="cov0" title="0">{
        return &amp;ZerologEvent{event: z.logger.Error()}
}</span>

// Debug implements Logger.Debug
func (z *ZerologLogger) Debug() Event <span class="cov0" title="0">{
        return &amp;ZerologEvent{event: z.logger.Debug()}
}</span>

// Warn implements Logger.Warn
func (z *ZerologLogger) Warn() Event <span class="cov0" title="0">{
        return &amp;ZerologEvent{event: z.logger.Warn()}
}</span>

// Fatal implements Logger.Fatal
func (z *ZerologLogger) Fatal() Event <span class="cov0" title="0">{
        return &amp;ZerologEvent{event: z.logger.Fatal()}
}</span>

// With implements Logger.With
func (z *ZerologLogger) With() Context <span class="cov0" title="0">{
        return &amp;ZerologContext{context: z.logger.With()}
}</span>

// ZerologEvent implements the Event interface
type ZerologEvent struct {
        event *zerolog.Event
}

// Msg implements Event.Msg
func (e *ZerologEvent) Msg(msg string) <span class="cov0" title="0">{
        e.event.Msg(msg)
}</span>

// Err implements Event.Err
func (e *ZerologEvent) Err(err error) Event <span class="cov0" title="0">{
        return &amp;ZerologEvent{event: e.event.Err(err)}
}</span>

// Str implements Event.Str
func (e *ZerologEvent) Str(key, val string) Event <span class="cov0" title="0">{
        return &amp;ZerologEvent{event: e.event.Str(key, val)}
}</span>

// Int implements Event.Int
func (e *ZerologEvent) Int(key string, val int) Event <span class="cov0" title="0">{
        return &amp;ZerologEvent{event: e.event.Int(key, val)}
}</span>

// Uint implements Event.Uint
func (e *ZerologEvent) Uint(key string, val uint) Event <span class="cov0" title="0">{
        return &amp;ZerologEvent{event: e.event.Uint(key, val)}
}</span>

// Bool implements Event.Bool
func (e *ZerologEvent) Bool(key string, val bool) Event <span class="cov0" title="0">{
        return &amp;ZerologEvent{event: e.event.Bool(key, val)}
}</span>

// ZerologContext implements the Context interface
type ZerologContext struct {
        context zerolog.Context
}

// Str implements Context.Str
func (c *ZerologContext) Str(key, val string) Context <span class="cov0" title="0">{
        return &amp;ZerologContext{context: c.context.Str(key, val)}
}</span>

// Int implements Context.Int
func (c *ZerologContext) Int(key string, val int) Context <span class="cov0" title="0">{
        return &amp;ZerologContext{context: c.context.Int(key, val)}
}</span>

// Uint implements Context.Uint
func (c *ZerologContext) Uint(key string, val uint) Context <span class="cov0" title="0">{
        return &amp;ZerologContext{context: c.context.Uint(key, val)}
}</span>

// Logger implements Context.Logger
func (c *ZerologContext) Logger() Logger <span class="cov0" title="0">{
        return &amp;ZerologLogger{logger: c.context.Logger()}
}</span>
</pre>
		
		<pre class="file" id="file56" style="display: none">package responses

import (
        "fmt"
        "net/http"

        "github.com/labstack/echo/v4"
)

type ErrorResponse struct {
        Error string `json:"error"`
}

type CreatedResponse struct {
        ID string `json:"id"`
}

func OK(c echo.Context, response interface{}) error <span class="cov0" title="0">{
        return c.JSON(http.StatusOK, response)
}</span>

func NoContent(c echo.Context) error <span class="cov0" title="0">{
        return c.NoContent(http.StatusNoContent)
}</span>

func NotFound(c echo.Context, response interface{}) error <span class="cov0" title="0">{
        return c.JSON(http.StatusNotFound, response)
}</span>

func BadRequest(c echo.Context, err error) error <span class="cov0" title="0">{
        return c.JSON(http.StatusBadRequest, ErrorResponse{Error: err.Error()})
}</span>

func InternalServerError(c echo.Context, err error) error <span class="cov0" title="0">{
        return c.JSON(http.StatusInternalServerError, ErrorResponse{Error: err.Error()})
}</span>

func Created(c echo.Context, id string) error <span class="cov0" title="0">{
        location := fmt.Sprintf("%s/%s", c.Request().URL.Path, id)
        c.Response().Header().Set("Location", location)
        return c.JSON(http.StatusCreated, CreatedResponse{ID: id})
}</span>
</pre>
		
		<pre class="file" id="file57" style="display: none">package utils

import "net"

// ToIPv4 convert an IP to IPv4 string if possible, or returns the original
func ToIPv4(ip string) string <span class="cov10" title="5">{
        parsed := net.ParseIP(ip)
        if parsed == nil </span><span class="cov1" title="1">{
                return ip
        }</span>
        <span class="cov8" title="4">if ipv4 := parsed.To4(); ipv4 != nil </span><span class="cov4" title="2">{
                return ipv4.String()
        }</span>
        <span class="cov4" title="2">if parsed.IsLoopback() </span><span class="cov1" title="1">{
                return "127.0.0.1"
        }</span>
        <span class="cov1" title="1">return ip</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
